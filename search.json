[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Code and data for “Assessing the quality of comparative genomics data and results with the cogeqc R/Bioconductor package”",
    "section": "",
    "text": "Preface\nThis book contains all code and data used in the paper Assessing the quality of comparative genomics data and results with the cogeqc R/Bioconductor package, and it is intended to make all analyses fully reproducible.\n\nABSTRACT\nComparative genomics has become an indispensable part of modern biology due to the advancements in high-throughput sequencing technologies and the accumulation of genomic data in public databases. However, the quality of genomic data and the choice of parameters used in software tools used for comparative genomics can greatly impact the accuracy of results. To address these issues, we present cogeqc, an R/Bioconductor package that provides researchers with a toolkit to assess genome assembly and annotation quality, orthogroup inference, and synteny detection. The package offers context-guided assessments of assembly and annotation statistics by comparing observed statistics to those of closely-related species on NCBI. To assess orthogroup inference, cogeqc calculates a protein domain-aware orthogroup score that aims at maximizing the number of shared protein domains within the same orthogroup. The assessment of synteny detection consists in representing anchor gene pairs as a synteny network and analyzing its graph properties, such as clustering coefficient, node count, and scale-free topology fit. The application of cogeqc to real data sets allowed for an evaluation of multiple parameter combinations for orthogroup inference and synteny detection, providing researchers with guidelines to aid in the selection of the most appropriate tools and parameters for their specific data."
  },
  {
    "objectID": "chapters/01_busco_assessment.html#managing-external-dependencies-with-virtual-environments",
    "href": "chapters/01_busco_assessment.html#managing-external-dependencies-with-virtual-environments",
    "title": "1  Assessing the completeness of Chlorophyta genomes",
    "section": "1.1 Managing external dependencies with virtual environments",
    "text": "1.1 Managing external dependencies with virtual environments\nHere, for convenience, we will install BUSCO in a Conda environment for use with cogeqc. For that, we will use the Bioconductor package Herper.\nBelow, you can find the code to install miniconda in a directory of your choice (here, “~/Documents”) and create a virtual environment containing a BUSCO installation.\n\n# Path to where BUSCO will be installed and env name\nmy_miniconda &lt;- file.path(\"~/Documents\", \"miniconda\")\nenv &lt;- \"cogeqc_env\"\n\n# Create env named `cogeqc_env` with BUSCO in it\ninstall_CondaTools(\n    tools = \"busco==5.3.0\", \n    env = env, \n    channels = c(\"conda-forge\", \"bioconda\"),\n    pathToMiniConda = my_miniconda\n)"
  },
  {
    "objectID": "chapters/01_busco_assessment.html#data-acquisition",
    "href": "chapters/01_busco_assessment.html#data-acquisition",
    "title": "1  Assessing the completeness of Chlorophyta genomes",
    "section": "1.2 Data acquisition",
    "text": "1.2 Data acquisition\nNow, we will load all genomes directly from PLAZA as DNAStringSet objects and export them to a single directory of FASTA files, so we can run BUSCO in batch mode.\n\n# Links to Chlorophyta genomes from Pico-PLAZA 3.0\nbase_url &lt;- \"ftp://ftp.psb.ugent.be/pub/plaza/plaza_pico_03/Genomes/\"\nlinks &lt;- paste0(\n    base_url, \n    c(\"mpu.fasta.gz\", \"mrcc299.fasta.gz\", \"olu.fasta.gz\", \"ome.fasta.gz\",\n      \"orcc809.fasta.gz\", \"ota.fasta.gz\", \"bprrcc1105.fasta.gz\",\n      \"cre.fasta.gz\", \"vca.fasta.gz\", \"cvu.fasta.gz\", \"acg.fasta.gz\",\n      \"pse3.fasta.gz\", \"prcc4223.fasta.gz\", \"cnc64a.fasta.gz\", \n      \"hsp.fasta.gz\", \"apr.fasta.gz\")\n)\n\n# Load all genomes\ngenomes &lt;- lapply(links, Biostrings::readDNAStringSet)\nnames(genomes) &lt;- basename(links)\n\n# Write all genomes to a subdirectory of tempdir\ngenomes_path &lt;- file.path(tempdir(), \"genomes\")\nif(!dir.exists(genomes_path)) { fs::dir_create(genomes_path) }\n\nwrite &lt;- lapply(seq_along(genomes), function(x) {\n    Biostrings::writeXStringSet(\n        x = genomes[[x]], \n        filepath = file.path(genomes_path, names(genomes)[x])\n    )\n    return(NULL)\n})"
  },
  {
    "objectID": "chapters/01_busco_assessment.html#running-busco",
    "href": "chapters/01_busco_assessment.html#running-busco",
    "title": "1  Assessing the completeness of Chlorophyta genomes",
    "section": "1.3 Running BUSCO",
    "text": "1.3 Running BUSCO\nNow that all genomes are stored as FASTA files in /tmp/Rtmp9EWuNG/genomes, we can assess their completeness with BUSCO.\n\n# See all possible lineage datasets\nwith_CondaEnv(\n    env, list_busco_datasets(), my_miniconda\n)\n\n# Run BUSCO using chlorophyta_odb10 as the lineage data set\nbusco &lt;- with_CondaEnv(\n    env,\n    run_busco(\n        sequence = genomes_path, \n        outlabel = \"chlorophyta_busco\",\n        mode = \"genome\",\n        lineage = \"chlorophyta_odb10\",\n        outpath = tempdir(),\n        download_path = tempdir()\n    ),\n    my_miniconda\n)\n\n# Read and parse the output\noutdir &lt;- file.path(tempdir(), \"chlorophyta_busco\")\nbusco_summary &lt;- read_busco(outdir)\nsave(\n    busco_summary,\n    file = here::here(\"products\", \"result_files\", \"busco_summary.rda\"),\n    compress = \"xz\"\n)\n\nThe parsed BUSCO output (as returned by read_busco()) looks like this:\n\nload(here(\"products\", \"result_files\", \"busco_summary.rda\"))\nhead(busco_summary)\n\n        Class Frequency           Lineage             File\n1 Complete_SC      94.1 chlorophyta_odb10    pse3.fasta.gz\n2 Complete_SC      95.1 chlorophyta_odb10     cre.fasta.gz\n3 Complete_SC      96.8 chlorophyta_odb10     olu.fasta.gz\n4 Complete_SC      98.7 chlorophyta_odb10 mrcc299.fasta.gz\n5 Complete_SC      91.8 chlorophyta_odb10     apr.fasta.gz\n6 Complete_SC      86.4 chlorophyta_odb10     acg.fasta.gz"
  },
  {
    "objectID": "chapters/01_busco_assessment.html#visualizing-summary-statistics",
    "href": "chapters/01_busco_assessment.html#visualizing-summary-statistics",
    "title": "1  Assessing the completeness of Chlorophyta genomes",
    "section": "1.4 Visualizing summary statistics",
    "text": "1.4 Visualizing summary statistics\nFinally, let’s visualize summary BUSCO stats:\n\n# Manually create tree based on Pico-PLAZA's tree\nc_branches &lt;- function(b1, b2) {\n    x &lt;- paste0(\"(\", b1, \",\", b2, \")\")\n}\n\nostreococcus_root &lt;- \"((((Ostreococcus_lucimarinus, Ostreococcus_sp_RCC809), Ostreococcus_tauri), Ostreococcus_mediterraneus), Bathycoccus_prasinos)\"\nmicromonas &lt;- \"(Micromonas_pusilla_strain_CCMP1545, Micromonas_sp_RCC299)\"\nchlamydomonadales &lt;- \"(Volvox_carteri, Chlamydomonas_reinhardtii)\"\npicochlorum &lt;- \"(Picochlorum_sp_SENEW3, Picochlorum_RCC4223)\"\nchlorellales &lt;- \"((Helicosporidium_sp, Auxenochlorella_protothecoides), Chlorella_sp_NC64A)\"\ntrebouxiophyceae &lt;- c_branches(\n    \"(Coccomyxa_subellipsoidea_C-169, Asterochloris_sp_Cgr/DA1pho_v2)\", \n    c_branches(picochlorum, chlorellales)\n)\n\nchlo_tree &lt;- c_branches(\n    c_branches(\n        ostreococcus_root, micromonas\n    ),\n    c_branches(\n        chlamydomonadales, trebouxiophyceae\n    )\n)\nchlo_tree &lt;- paste0(chlo_tree, \";\")\n\n# Read tree as a phylo object and clean species names\nchlo_tree &lt;- treeio::read.tree(text = chlo_tree)\nchlo_tree$tip.label &lt;- gsub(\"_\", \" \", chlo_tree$tip.label)\n\n# Plot species tree and get species order from tree topology\np_tree &lt;- plot_species_tree(chlo_tree, xlim = c(0, 12))\ntaxa_order &lt;- rev(ggtree::get_taxa_name(p_tree)) \n\n# Plot BUSCO summary stats\np_busco &lt;- busco_summary %&gt;%\n    mutate(File = str_replace_all(File, \"\\\\.fasta.*\", \"\")) %&gt;%\n    mutate(File = str_replace_all(\n        File,\n        c(\n            \"pse3\" = \"Picochlorum sp SENEW3\",\n            \"cre\" = \"Chlamydomonas reinhardtii\",\n            \"olu\" = \"Ostreococcus lucimarinus\",\n            \"mrcc299\" = \"Micromonas sp RCC299\",\n            \"apr\" = \"Auxenochlorella protothecoides\",\n            \"acg\" = \"Asterochloris sp Cgr/DA1pho v2\",\n            \"cvu\" = \"Coccomyxa subellipsoidea C-169\",\n            \"bprrcc1105\" = \"Bathycoccus prasinos\",\n            \"orcc809\" = \"Ostreococcus sp RCC809\",\n            \"prcc4223\" = \"Picochlorum RCC4223\",\n            \"ota\" = \"Ostreococcus tauri\",\n            \"hsp\" = \"Helicosporidium sp\",\n            \"mpu\" = \"Micromonas pusilla strain CCMP1545\",\n            \"vca\" = \"Volvox carteri\",\n            \"ome\" = \"Ostreococcus mediterraneus\",\n            \"cnc64a\" = \"Chlorella sp NC64A\"\n        )\n    )) %&gt;%\n    mutate(File = factor(File, taxa_order)) %&gt;%\n    plot_busco() +\n    theme(axis.text.y = element_blank()) +\n    labs(y = \"\")\n\n# Combining phylogeny with BUSCO plot\ncombined &lt;- patchwork::wrap_plots(p_tree, p_busco)\ncombined\n\n\n\n\nBUSCO scores for Chlorophyta genomes on Pico-PLAZA 3.0.\n\n\n\n\nExcept for Helicosporidium sp., Chlorophyta genomes on Pico-PLAZA 3.0 have a high quality, as denoted by their high completeness."
  },
  {
    "objectID": "chapters/01_busco_assessment.html#session-info",
    "href": "chapters/01_busco_assessment.html#session-info",
    "title": "1  Assessing the completeness of Chlorophyta genomes",
    "section": "Session info",
    "text": "Session info\nThis document was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.0 (2023-04-21)\n os       Ubuntu 20.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2023-08-01\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package          * version   date (UTC) lib source\n ape                5.7-1     2023-03-13 [1] CRAN (R 4.3.0)\n aplot              0.1.10    2023-03-08 [1] CRAN (R 4.3.0)\n beeswarm           0.4.0     2021-06-01 [1] CRAN (R 4.3.0)\n BiocGenerics       0.46.0    2023-04-25 [1] Bioconductor\n BiocManager        1.30.20   2023-02-24 [1] CRAN (R 4.3.0)\n BiocStyle          2.28.0    2023-04-25 [1] Bioconductor\n Biostrings         2.68.0    2023-04-25 [1] Bioconductor\n bitops             1.0-7     2021-04-24 [1] CRAN (R 4.3.0)\n cli                3.6.1     2023-03-23 [1] CRAN (R 4.3.0)\n cogeqc           * 1.4.0     2023-04-25 [1] Bioconductor\n colorspace         2.1-0     2023-01-23 [1] CRAN (R 4.3.0)\n crayon             1.5.2     2022-09-29 [1] CRAN (R 4.3.0)\n digest             0.6.31    2022-12-11 [1] CRAN (R 4.3.0)\n dplyr            * 1.1.2     2023-04-20 [1] CRAN (R 4.3.0)\n evaluate           0.20      2023-01-17 [1] CRAN (R 4.3.0)\n fansi              1.0.4     2023-01-22 [1] CRAN (R 4.3.0)\n farver             2.1.1     2022-07-06 [1] CRAN (R 4.3.0)\n fastmap            1.1.1     2023-02-24 [1] CRAN (R 4.3.0)\n forcats          * 1.0.0     2023-01-29 [1] CRAN (R 4.3.0)\n fs                 1.6.2     2023-04-25 [1] CRAN (R 4.3.0)\n generics           0.1.3     2022-07-05 [1] CRAN (R 4.3.0)\n GenomeInfoDb       1.36.0    2023-04-25 [1] Bioconductor\n GenomeInfoDbData   1.2.10    2023-04-28 [1] Bioconductor\n ggbeeswarm         0.7.2     2023-04-29 [1] CRAN (R 4.3.0)\n ggfun              0.0.9     2022-11-21 [1] CRAN (R 4.3.0)\n ggplot2          * 3.4.1     2023-02-10 [1] CRAN (R 4.3.0)\n ggplotify          0.1.0     2021-09-02 [1] CRAN (R 4.3.0)\n ggtree             3.8.0     2023-04-25 [1] Bioconductor\n glue               1.6.2     2022-02-24 [1] CRAN (R 4.3.0)\n gridGraphics       0.5-1     2020-12-13 [1] CRAN (R 4.3.0)\n gtable             0.3.3     2023-03-21 [1] CRAN (R 4.3.0)\n here             * 1.0.1     2020-12-13 [1] CRAN (R 4.3.0)\n Herper           * 1.10.1    2023-07-12 [1] Bioconductor\n hms                1.1.3     2023-03-21 [1] CRAN (R 4.3.0)\n htmltools          0.5.5     2023-03-23 [1] CRAN (R 4.3.0)\n htmlwidgets        1.6.2     2023-03-17 [1] CRAN (R 4.3.0)\n igraph             1.4.2     2023-04-07 [1] CRAN (R 4.3.0)\n IRanges            2.34.0    2023-04-25 [1] Bioconductor\n jsonlite           1.8.4     2022-12-06 [1] CRAN (R 4.3.0)\n knitr              1.42      2023-01-25 [1] CRAN (R 4.3.0)\n labeling           0.4.2     2020-10-20 [1] CRAN (R 4.3.0)\n lattice            0.20-45   2021-09-22 [4] CRAN (R 4.2.0)\n lazyeval           0.2.2     2019-03-15 [1] CRAN (R 4.3.0)\n lifecycle          1.0.3     2022-10-07 [1] CRAN (R 4.3.0)\n lubridate        * 1.9.2     2023-02-10 [1] CRAN (R 4.3.0)\n magrittr           2.0.3     2022-03-30 [1] CRAN (R 4.3.0)\n Matrix             1.5-1     2022-09-13 [4] CRAN (R 4.2.1)\n munsell            0.5.0     2018-06-12 [1] CRAN (R 4.3.0)\n nlme               3.1-162   2023-01-31 [4] CRAN (R 4.2.2)\n patchwork          1.1.2     2022-08-19 [1] CRAN (R 4.3.0)\n pillar             1.9.0     2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig          2.0.3     2019-09-22 [1] CRAN (R 4.3.0)\n plyr               1.8.8     2022-11-11 [1] CRAN (R 4.3.0)\n png                0.1-8     2022-11-29 [1] CRAN (R 4.3.0)\n purrr            * 1.0.1     2023-01-10 [1] CRAN (R 4.3.0)\n R6                 2.5.1     2021-08-19 [1] CRAN (R 4.3.0)\n Rcpp               1.0.10    2023-01-22 [1] CRAN (R 4.3.0)\n RCurl              1.98-1.12 2023-03-27 [1] CRAN (R 4.3.0)\n readr            * 2.1.4     2023-02-10 [1] CRAN (R 4.3.0)\n reshape2           1.4.4     2020-04-09 [1] CRAN (R 4.3.0)\n reticulate       * 1.30      2023-06-09 [1] CRAN (R 4.3.0)\n rjson              0.2.21    2022-01-09 [1] CRAN (R 4.3.0)\n rlang              1.1.1     2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown          2.21      2023-03-26 [1] CRAN (R 4.3.0)\n rprojroot          2.0.3     2022-04-02 [1] CRAN (R 4.3.0)\n rstudioapi         0.14      2022-08-22 [1] CRAN (R 4.3.0)\n S4Vectors          0.38.0    2023-04-25 [1] Bioconductor\n scales             1.2.1     2022-08-20 [1] CRAN (R 4.3.0)\n sessioninfo        1.2.2     2021-12-06 [1] CRAN (R 4.3.0)\n stringi            1.7.12    2023-01-11 [1] CRAN (R 4.3.0)\n stringr          * 1.5.0     2022-12-02 [1] CRAN (R 4.3.0)\n tibble           * 3.2.1     2023-03-20 [1] CRAN (R 4.3.0)\n tidyr            * 1.3.0     2023-01-24 [1] CRAN (R 4.3.0)\n tidyselect         1.2.0     2022-10-10 [1] CRAN (R 4.3.0)\n tidytree           0.4.2     2022-12-18 [1] CRAN (R 4.3.0)\n tidyverse        * 2.0.0     2023-02-22 [1] CRAN (R 4.3.0)\n timechange         0.2.0     2023-01-11 [1] CRAN (R 4.3.0)\n treeio             1.24.1    2023-05-31 [1] Bioconductor\n tzdb               0.3.0     2022-03-28 [1] CRAN (R 4.3.0)\n utf8               1.2.3     2023-01-31 [1] CRAN (R 4.3.0)\n vctrs              0.6.2     2023-04-19 [1] CRAN (R 4.3.0)\n vipor              0.4.5     2017-03-22 [1] CRAN (R 4.3.0)\n withr              2.5.0     2022-03-03 [1] CRAN (R 4.3.0)\n xfun               0.39      2023-04-20 [1] CRAN (R 4.3.0)\n XVector            0.40.0    2023-04-25 [1] Bioconductor\n yaml               2.3.7     2023-01-23 [1] CRAN (R 4.3.0)\n yulab.utils        0.0.6     2022-12-20 [1] CRAN (R 4.3.0)\n zlibbioc           1.46.0    2023-04-25 [1] Bioconductor\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "chapters/01_busco_assessment.html#references",
    "href": "chapters/01_busco_assessment.html#references",
    "title": "1  Assessing the completeness of Chlorophyta genomes",
    "section": "References",
    "text": "References\n\n\n\n\nVan Bel, Michiel, Tim Diels, Emmelien Vancaester, Lukasz Kreft, Alexander Botzki, Yves Van de Peer, Frederik Coppens, and Klaas Vandepoele. 2018. “PLAZA 4.0: An Integrative Resource for Functional, Evolutionary and Comparative Plant Genomics.” Nucleic Acids Research 46 (D1): D1190–96."
  },
  {
    "objectID": "chapters/02_orthogroup_assessment_orthobench.html#data-acquisition",
    "href": "chapters/02_orthogroup_assessment_orthobench.html#data-acquisition",
    "title": "2  Orthogroup assessment in Orthobench",
    "section": "2.1 Data acquisition",
    "text": "2.1 Data acquisition\nThe data set can be obtained in this GitHub repository. First, let’s create a data frame containing all gene IDs for each species.\n\n# Repo's URL\nurl &lt;- \"https://api.github.com/repos/davidemms/Open_Orthobench/git/trees/master?recursive=2\"\n\n# Get all file paths\npaths &lt;- GET(url) |&gt; content()\n\n# Get only file paths for sequence files\npaths &lt;- unlist(lapply(paths$tree, function(x) x$path))\nsequence_paths &lt;- data.frame(\n    Path = paths\n) |&gt; \n    separate(Path, c(\"base\", \"folder\", \"filename\"), \"/\") |&gt;\n    filter(folder == \"Input\") |&gt;\n    filter(str_detect(filename, \"\\\\.fa\")) |&gt;\n    mutate(\n        download_path = file.path(\n            \"https://github.com/davidemms/Open_Orthobench/raw/master\",\n            base, folder, filename\n        )\n    )\n\n# Create a data frame of gene IDs per species\ngenes_per_species &lt;- Reduce(rbind, lapply(seq_len(nrow(sequence_paths)), function(x) {\n    \n    species &lt;- gsub(\".pep.*\", \"\", sequence_paths$filename[x])\n    gene_ids &lt;- names(\n        Biostrings::readAAStringSet(sequence_paths$download_path[x])\n    )\n    \n    species_and_genes &lt;- data.frame(\n        Species = species,\n        Gene = gene_ids\n    )\n    \n    return(species_and_genes)\n}))\n\nNow, we will get all reference orthogroups from Orthobench and reshape them so that they look like the standard orthogroup data frame in cogeqc (with columns Orthogroup, Species, and Gene).\n\n# Get URL to each orthogroup\nog_paths &lt;- data.frame(\n    Path = paths\n) |&gt; \n    separate(Path, c(\"base\", \"folder\", \"filename\"), \"/\") |&gt;\n    filter(folder == \"RefOGs\") |&gt;\n    filter(str_detect(filename, \"\\\\.txt\")) |&gt;\n    mutate(\n        download_path = file.path(\n            \"https://github.com/davidemms/Open_Orthobench/raw/master\",\n            base, folder, filename\n        )\n    )\n\n# Read orthogroups and reformat them as cogeqc's orthogroup data frame\nreference_ogs &lt;- Reduce(rbind, lapply(seq_len(nrow(og_paths)), function(x) {\n    \n    og_name &lt;- gsub(\".txt\", \"\", og_paths$filename[x])\n    og_genes &lt;- readLines(og_paths$download_path[x])\n    \n    og_df &lt;- data.frame(\n        Orthogroup = og_name,\n        Gene = og_genes\n    ) |&gt;\n        left_join(genes_per_species) |&gt;\n        dplyr::select(Orthogroup, Species, Gene)\n    \n    return(og_df)\n}))\n\nFinally, we will use the biomartr package (Drost and Paszkowski 2017) to obtain protein domain annotation for each species from Ensembl.\n\nannotation_list &lt;- lapply(unique(reference_ogs$Species), function(x) {\n    \n    species_id &lt;- paste0(\n        tolower(substr(x, 1, 1)), # first letter of genus\n        gsub(\".*_\", \"\", gsub(\"\\\\..*\", \"\", x)) # entire specific epithet\n    )\n    \n    if(startsWith(x, \"Canis\")) {\n        species_id &lt;- \"clfamiliaris\"\n    }\n    \n    genes &lt;- reference_ogs |&gt;\n        filter(Species == x) |&gt;\n        pull(Gene)\n    \n    annot &lt;- biomart(\n        genes = genes,\n        mart = \"ENSEMBL_MART_ENSEMBL\",\n        dataset = paste0(species_id, \"_gene_ensembl\"),\n        attributes = \"interpro\",\n        filters = \"ensembl_peptide_id\"\n    ) |&gt;\n        dplyr::select(Gene = ensembl_peptide_id, Annotation = interpro)\n    \n    return(annot)\n})\nnames(annotation_list) &lt;- unique(reference_ogs$Species)\n\n# Remove empty elements (i.e., species for which we could not obtain annotation)\nempty &lt;- sapply(annotation_list, nrow) == 0\nannotation_list &lt;- annotation_list[!empty]"
  },
  {
    "objectID": "chapters/02_orthogroup_assessment_orthobench.html#orthogroup-assessment",
    "href": "chapters/02_orthogroup_assessment_orthobench.html#orthogroup-assessment",
    "title": "2  Orthogroup assessment in Orthobench",
    "section": "2.2 Orthogroup assessment",
    "text": "2.2 Orthogroup assessment\nNow that we have the orthogroup data frame and the annotation list, we can calculate homogeneity scores.\n\np_orthobench_homogeneity &lt;- reference_ogs |&gt;\n    ## Remove species for which we could not obtain domain annotation\n    filter(Species %in% names(annotation_list)) |&gt;\n    ## Calculate homogeneity scores\n    left_join(Reduce(rbind, annotation_list)) |&gt;\n    calculate_H(correct_overclustering = FALSE) |&gt;\n    dplyr::filter(!is.na(Score)) |&gt;\n    ## Plot a histogram of scores\n    ggplot(aes(x = Score, y = ..count../sum(..count..))) +\n    geom_histogram(fill = \"grey60\", color = \"black\", bins = 60) +\n    labs(\n        title = \"Homogeneity scores for Orthobench's reference orthogroups\",\n        y = \"Relative frequency\", x = \"Homogeneity scores\"\n    ) +\n    xlim(0, 1) +\n    theme_bw()\n\np_orthobench_homogeneity\n\n\n\n\nHomogeneity scores for Orthobench’s reference orthogroups.\n\n\n\n\nThe plot shows that homogeneity scores for reference orthogroups tend to be very close to 1, as expected, which validates the rationale behind our approach. Of note, most orthogroups do not reach perfect homogeneity, probably due to domain gains and losses throughout their evolution, but they are still very close to 1. In summary, our findings here demonstrate that reference-quality orthogroups should indeed have homogeneity scores as close to 1 as possible, and users should seek a similar distribution when inferring orthogroups for their own data sets."
  },
  {
    "objectID": "chapters/02_orthogroup_assessment_orthobench.html#session-info",
    "href": "chapters/02_orthogroup_assessment_orthobench.html#session-info",
    "title": "2  Orthogroup assessment in Orthobench",
    "section": "Session info",
    "text": "Session info\nThis document was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.0 (2023-04-21)\n os       Ubuntu 20.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2023-08-07\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package          * version   date (UTC) lib source\n AnnotationDbi      1.62.0    2023-04-25 [1] Bioconductor\n ape                5.7-1     2023-03-13 [1] CRAN (R 4.3.0)\n aplot              0.1.10    2023-03-08 [1] CRAN (R 4.3.0)\n beeswarm           0.4.0     2021-06-01 [1] CRAN (R 4.3.0)\n Biobase            2.60.0    2023-04-25 [1] Bioconductor\n BiocFileCache      2.8.0     2023-04-25 [1] Bioconductor\n BiocGenerics       0.46.0    2023-04-25 [1] Bioconductor\n biomaRt            2.56.0    2023-04-25 [1] Bioconductor\n biomartr         * 1.0.3     2023-05-07 [1] CRAN (R 4.3.0)\n Biostrings         2.68.0    2023-04-25 [1] Bioconductor\n bit                4.0.5     2022-11-15 [1] CRAN (R 4.3.0)\n bit64              4.0.5     2020-08-30 [1] CRAN (R 4.3.0)\n bitops             1.0-7     2021-04-24 [1] CRAN (R 4.3.0)\n blob               1.2.4     2023-03-17 [1] CRAN (R 4.3.0)\n cachem             1.0.8     2023-05-01 [1] CRAN (R 4.3.0)\n cli                3.6.1     2023-03-23 [1] CRAN (R 4.3.0)\n cogeqc           * 1.4.0     2023-04-25 [1] Bioconductor\n colorspace         2.1-0     2023-01-23 [1] CRAN (R 4.3.0)\n crayon             1.5.2     2022-09-29 [1] CRAN (R 4.3.0)\n curl               5.0.0     2023-01-12 [1] CRAN (R 4.3.0)\n data.table         1.14.8    2023-02-17 [1] CRAN (R 4.3.0)\n DBI                1.1.3     2022-06-18 [1] CRAN (R 4.3.0)\n dbplyr             2.3.2     2023-03-21 [1] CRAN (R 4.3.0)\n digest             0.6.33    2023-07-07 [1] CRAN (R 4.3.0)\n dplyr            * 1.1.2     2023-04-20 [1] CRAN (R 4.3.0)\n evaluate           0.21      2023-05-05 [1] CRAN (R 4.3.0)\n fansi              1.0.4     2023-01-22 [1] CRAN (R 4.3.0)\n farver             2.1.1     2022-07-06 [1] CRAN (R 4.3.0)\n fastmap            1.1.1     2023-02-24 [1] CRAN (R 4.3.0)\n filelock           1.0.2     2018-10-05 [1] CRAN (R 4.3.0)\n forcats          * 1.0.0     2023-01-29 [1] CRAN (R 4.3.0)\n generics           0.1.3     2022-07-05 [1] CRAN (R 4.3.0)\n GenomeInfoDb       1.36.0    2023-04-25 [1] Bioconductor\n GenomeInfoDbData   1.2.10    2023-04-28 [1] Bioconductor\n ggbeeswarm         0.7.2     2023-04-29 [1] CRAN (R 4.3.0)\n ggfun              0.0.9     2022-11-21 [1] CRAN (R 4.3.0)\n ggplot2          * 3.4.1     2023-02-10 [1] CRAN (R 4.3.0)\n ggplotify          0.1.0     2021-09-02 [1] CRAN (R 4.3.0)\n ggtree             3.8.0     2023-04-25 [1] Bioconductor\n glue               1.6.2     2022-02-24 [1] CRAN (R 4.3.0)\n gridGraphics       0.5-1     2020-12-13 [1] CRAN (R 4.3.0)\n gtable             0.3.3     2023-03-21 [1] CRAN (R 4.3.0)\n here             * 1.0.1     2020-12-13 [1] CRAN (R 4.3.0)\n hms                1.1.3     2023-03-21 [1] CRAN (R 4.3.0)\n htmltools          0.5.5     2023-03-23 [1] CRAN (R 4.3.0)\n htmlwidgets        1.6.2     2023-03-17 [1] CRAN (R 4.3.0)\n httr             * 1.4.5     2023-02-24 [1] CRAN (R 4.3.0)\n igraph             1.4.2     2023-04-07 [1] CRAN (R 4.3.0)\n IRanges            2.34.0    2023-04-25 [1] Bioconductor\n jsonlite           1.8.7     2023-06-29 [1] CRAN (R 4.3.0)\n KEGGREST           1.40.0    2023-04-25 [1] Bioconductor\n knitr              1.43      2023-05-25 [1] CRAN (R 4.3.0)\n labeling           0.4.2     2020-10-20 [1] CRAN (R 4.3.0)\n lattice            0.20-45   2021-09-22 [4] CRAN (R 4.2.0)\n lazyeval           0.2.2     2019-03-15 [1] CRAN (R 4.3.0)\n lifecycle          1.0.3     2022-10-07 [1] CRAN (R 4.3.0)\n lubridate        * 1.9.2     2023-02-10 [1] CRAN (R 4.3.0)\n magrittr           2.0.3     2022-03-30 [1] CRAN (R 4.3.0)\n memoise            2.0.1     2021-11-26 [1] CRAN (R 4.3.0)\n munsell            0.5.0     2018-06-12 [1] CRAN (R 4.3.0)\n nlme               3.1-162   2023-01-31 [4] CRAN (R 4.2.2)\n patchwork          1.1.2     2022-08-19 [1] CRAN (R 4.3.0)\n pillar             1.9.0     2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig          2.0.3     2019-09-22 [1] CRAN (R 4.3.0)\n plyr               1.8.8     2022-11-11 [1] CRAN (R 4.3.0)\n png                0.1-8     2022-11-29 [1] CRAN (R 4.3.0)\n prettyunits        1.1.1     2020-01-24 [1] CRAN (R 4.3.0)\n progress           1.2.2     2019-05-16 [1] CRAN (R 4.3.0)\n purrr            * 1.0.1     2023-01-10 [1] CRAN (R 4.3.0)\n R6                 2.5.1     2021-08-19 [1] CRAN (R 4.3.0)\n rappdirs           0.3.3     2021-01-31 [1] CRAN (R 4.3.0)\n Rcpp               1.0.10    2023-01-22 [1] CRAN (R 4.3.0)\n RCurl              1.98-1.12 2023-03-27 [1] CRAN (R 4.3.0)\n readr            * 2.1.4     2023-02-10 [1] CRAN (R 4.3.0)\n reshape2           1.4.4     2020-04-09 [1] CRAN (R 4.3.0)\n rlang              1.1.1     2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown          2.23      2023-07-01 [1] CRAN (R 4.3.0)\n rprojroot          2.0.3     2022-04-02 [1] CRAN (R 4.3.0)\n RSQLite            2.3.1     2023-04-03 [1] CRAN (R 4.3.0)\n rstudioapi         0.14      2022-08-22 [1] CRAN (R 4.3.0)\n S4Vectors          0.38.0    2023-04-25 [1] Bioconductor\n scales             1.2.1     2022-08-20 [1] CRAN (R 4.3.0)\n sessioninfo        1.2.2     2021-12-06 [1] CRAN (R 4.3.0)\n stringi            1.7.12    2023-01-11 [1] CRAN (R 4.3.0)\n stringr          * 1.5.0     2022-12-02 [1] CRAN (R 4.3.0)\n tibble           * 3.2.1     2023-03-20 [1] CRAN (R 4.3.0)\n tidyr            * 1.3.0     2023-01-24 [1] CRAN (R 4.3.0)\n tidyselect         1.2.0     2022-10-10 [1] CRAN (R 4.3.0)\n tidytree           0.4.2     2022-12-18 [1] CRAN (R 4.3.0)\n tidyverse        * 2.0.0     2023-02-22 [1] CRAN (R 4.3.0)\n timechange         0.2.0     2023-01-11 [1] CRAN (R 4.3.0)\n treeio             1.24.1    2023-05-31 [1] Bioconductor\n tzdb               0.3.0     2022-03-28 [1] CRAN (R 4.3.0)\n utf8               1.2.3     2023-01-31 [1] CRAN (R 4.3.0)\n vctrs              0.6.3     2023-06-14 [1] CRAN (R 4.3.0)\n vipor              0.4.5     2017-03-22 [1] CRAN (R 4.3.0)\n withr              2.5.0     2022-03-03 [1] CRAN (R 4.3.0)\n xfun               0.39      2023-04-20 [1] CRAN (R 4.3.0)\n XML                3.99-0.14 2023-03-19 [1] CRAN (R 4.3.0)\n xml2               1.3.4     2023-04-27 [1] CRAN (R 4.3.0)\n XVector            0.40.0    2023-04-25 [1] Bioconductor\n yaml               2.3.7     2023-01-23 [1] CRAN (R 4.3.0)\n yulab.utils        0.0.6     2022-12-20 [1] CRAN (R 4.3.0)\n zlibbioc           1.46.0    2023-04-25 [1] Bioconductor\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "chapters/02_orthogroup_assessment_orthobench.html#references",
    "href": "chapters/02_orthogroup_assessment_orthobench.html#references",
    "title": "2  Orthogroup assessment in Orthobench",
    "section": "References",
    "text": "References\n\n\n\n\nDrost, Hajk-Georg, and Jerzy Paszkowski. 2017. “Biomartr: Genomic Data Retrieval with r.” Bioinformatics 33 (8): 1216–17.\n\n\nEmms, David M, and Steven Kelly. 2020. “Benchmarking Orthogroup Inference Accuracy: Revisiting Orthobench.” Genome Biology and Evolution 12 (12): 2258–66.\n\n\nTrachana, Kalliopi, Tomas A Larsson, Sean Powell, Wei-Hua Chen, Tobias Doerks, Jean Muller, and Peer Bork. 2011. “Orthology Prediction Methods: A Quality Assessment Using Curated Protein Families.” Bioessays 33 (10): 769–80."
  },
  {
    "objectID": "chapters/03_orthogroup_inference_dbs.html#calculating-orthogroup-scores",
    "href": "chapters/03_orthogroup_inference_dbs.html#calculating-orthogroup-scores",
    "title": "3  Assessing orthogroup inference in public databases",
    "section": "3.1 Calculating orthogroup scores",
    "text": "3.1 Calculating orthogroup scores\nTo make comparison possible, we will Arabidopsis thaliana domain annotation as a proxy, as this species is present in all of the aforementioned databases. For that, we will use the function calculate_H() from cogeqc.\nOrthogroups assignments from OrthoDB, eggNOG, InParanoid, PhylomeDB, and HOGENOM will be obtained from UniProt.\n\n3.1.1 PLAZA Dicots 5.0\nBelow, we will obtain orthogroups and A. thaliana’s domain annotation from PLAZA 5.0, and then we will calculate homogeneity scores for each orthogroup.\n\n# Obtain gene families from PLAZA\nfams_plaza &lt;- readr::read_tsv(\n    paste0(\n        \"https://ftp.psb.ugent.be/pub/plaza/plaza_public_dicots_05/\",\n        \"GeneFamilies/genefamily_data.HOMFAM.csv.gz\"\n    ), show_col_types = FALSE, skip = 2\n) %&gt;%\n    filter(species == \"ath\") %&gt;%\n    as.data.frame()\nnames(fams_plaza) &lt;- c(\"Orthogroup\", \"Species\", \"Gene\")\nhead(fams_plaza)\n\n    Orthogroup Species      Gene\n1 HOM05D000001     ath AT1G02310\n2 HOM05D000001     ath AT1G03510\n3 HOM05D000001     ath AT1G03540\n4 HOM05D000001     ath AT1G04020\n5 HOM05D000001     ath AT1G04840\n6 HOM05D000001     ath AT1G05750\n\n# Obtain domain anotation for A. thaliana\nath_interpro &lt;- readr::read_tsv(\n    paste0(\n        \"https://ftp.psb.ugent.be/pub/plaza/plaza_public_dicots_05/\",\n        \"InterPro/interpro.ath.csv.gz\"\n    ), show_col_types = FALSE, skip = 8\n) %&gt;%\n    select(1,3)\nnames(ath_interpro) &lt;- c(\"Gene\", \"Annotation\")\nhead(ath_interpro)\n\n# A tibble: 6 × 2\n  Gene      Annotation\n  &lt;chr&gt;     &lt;chr&gt;     \n1 AT1G01010 IPR036093 \n2 AT1G01010 IPR003441 \n3 AT1G01010 IPR036093 \n4 AT1G01020 IPR007290 \n5 AT1G01020 IPR007290 \n6 AT1G01030 IPR003340 \n\n# Combining everything and calculating homogeneity scores\nfam_df_plaza &lt;- merge(fams_plaza, ath_interpro)\nhead(fam_df_plaza)\n\n       Gene   Orthogroup Species Annotation\n1 AT1G01010 HOM05D000010     ath  IPR036093\n2 AT1G01010 HOM05D000010     ath  IPR003441\n3 AT1G01010 HOM05D000010     ath  IPR036093\n4 AT1G01020 HOM05D006082     ath  IPR007290\n5 AT1G01020 HOM05D006082     ath  IPR007290\n6 AT1G01030 HOM05D000466     ath  IPR015300\n\nH_summary &lt;- function(ortho_df = NULL) {\n    H &lt;- calculate_H(ortho_df)\n    mean_H &lt;- round(mean(H$Score), 2)\n    median_H &lt;- round(median(H$Score), 2)\n    result_list &lt;- list(H = H, mean_score = mean_H, median_score = median_H)\n    return(result_list)\n}\n\nH_plaza &lt;- H_summary(fam_df_plaza)\nhead(H_plaza$H)\n\n    Orthogroup     Score\n1 HOM05D000001  283.3132\n2 HOM05D000002  129.9598\n3 HOM05D000003  889.1268\n4 HOM05D000004    0.0000\n5 HOM05D000005 1135.8799\n6 HOM05D000006 2820.8337\n\n\n\n\n3.1.2 OrthoDB, eggNOG, and HOGENOM\nOrthogroup assignments from these databases will be obtained from UniProt (Consortium 2021).\n\n# Get list of proteins - from primary transcripts only\nath_proteome &lt;- Biostrings::readAAStringSet(\n    paste0(\n        \"https://ftp.uniprot.org/pub/databases/uniprot/\",\n        \"current_release/knowledgebase/reference_proteomes/Eukaryota/\",\n        \"UP000006548/UP000006548_3702.fasta.gz\"\n    )\n)\nath_proteins &lt;- names(ath_proteome)\nath_proteins &lt;- sapply(strsplit(ath_proteins, split = \"\\\\|\"), `[`, 2)\n\n# Extract phylogenomic information for all genes\nsource(here::here(\"code\", \"utils.R\"))\nfams_uniprot &lt;- extract_ogs_uniprot(ath_proteins)\n\nfams_orthodb &lt;- fams_uniprot[, c(\"Gene\", \"OrthoDB\")] %&gt;% drop_na()\nfams_eggnog &lt;- fams_uniprot[, c(\"Gene\", \"eggNOG\")] %&gt;% drop_na()\nfams_hogenom &lt;- fams_uniprot[, c(\"Gene\", \"HOGENOM\")] %&gt;% drop_na()\n\n#----Calculate homogeneity scores for each database-----------------------------\n# OrthoDB\nfams_df_orthodb &lt;- merge(fams_orthodb, ath_interpro)\nnames(fams_df_orthodb)[2] &lt;- \"Orthogroup\"\nH_orthodb &lt;- H_summary(fams_df_orthodb)\n\n# eggNOG\nfams_df_eggnog &lt;- merge(fams_eggnog, ath_interpro)\nnames(fams_df_eggnog)[2] &lt;- \"Orthogroup\"\nH_eggnog &lt;- H_summary(fams_df_eggnog)\n\n# HOGENOM\nfams_df_hogenom &lt;- merge(fams_hogenom, ath_interpro)\nnames(fams_df_hogenom)[2] &lt;- \"Orthogroup\"\nH_hogenom &lt;- H_summary(fams_df_hogenom)"
  },
  {
    "objectID": "chapters/03_orthogroup_inference_dbs.html#comparing-homogeneity-scores",
    "href": "chapters/03_orthogroup_inference_dbs.html#comparing-homogeneity-scores",
    "title": "3  Assessing orthogroup inference in public databases",
    "section": "3.2 Comparing homogeneity scores",
    "text": "3.2 Comparing homogeneity scores\nFinally, let’s compare homogeneity scores and visualize their distributions. First, let’s combine all data frames of homogeneity scores into a single data frame.\n\nH_combined &lt;- bind_rows(\n    H_plaza$H %&gt;% mutate(Source = \"PLAZA\"),\n    H_orthodb$H %&gt;% mutate(Source = \"OrthoDB\"),\n    H_eggnog$H %&gt;% mutate(Source = \"eggNOG\"),\n    H_hogenom$H %&gt;% mutate(Source = \"HOGENOM\")\n)\n\nsave(\n    H_combined,\n    file = here::here(\"products\", \"result_files\", \"H_combined.rda\"),\n    compress = \"xz\"\n)\n\nNow, let’s compare the distributions of homogeneity scores for each database to see if there are any differences. For that, we will calculate P-values from a Wilcoxon test with Wicoxon effect sizes (r). The Wilcoxon effect size is calculated as the Z statistic divided by the square root of the sample size.\n\n# Scale scores to maximum, so that they range from 0 to 1\nH_combined$Score &lt;- H_combined$Score / max(H_combined$Score)\nhead(H_combined)\n\n    Orthogroup      Score Source\n1 HOM05D000001 0.10043599  PLAZA\n2 HOM05D000002 0.04607143  PLAZA\n3 HOM05D000003 0.31520000  PLAZA\n4 HOM05D000004 0.00000000  PLAZA\n5 HOM05D000005 0.40267523  PLAZA\n6 HOM05D000006 1.00000000  PLAZA\n\n# Quick exploration of means and medians\nH_combined %&gt;%\n    group_by(Source) %&gt;%\n    summarise(mean = mean(Score), median = median(Score))\n\n# A tibble: 4 × 3\n  Source   mean median\n  &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n1 HOGENOM 0.603  0.609\n2 OrthoDB 0.578  0.567\n3 PLAZA   0.610  0.6  \n4 eggNOG  0.565  0.546\n\n# Compare homogeneity scores - all vs all\ndb_wilcox &lt;- compare(H_combined, \"Score ~ Source\")\n\ndb_wilcox |&gt;\n    filter_comparison() |&gt;\n    knitr::kable(\n        caption = \"Mann-Whitney U test for differences in orthogroup scores with Wilcoxon effect sizes.\",\n        digits = 10\n    )\n\n\nMann-Whitney U test for differences in orthogroup scores with Wilcoxon effect sizes.\n\n\ngroup1\ngroup2\nn1\nn2\npadj\neffsize\nmagnitude\n\n\n\n\neggNOG\nHOGENOM\n3092\n3257\n0.0e+00\n0.11102956\nsmall\n\n\neggNOG\nOrthoDB\n3092\n3201\n8.5e-09\n0.07197679\nsmall\n\n\neggNOG\nPLAZA\n3092\n3503\n0.0e+00\n0.09434683\nsmall\n\n\nHOGENOM\nOrthoDB\n3257\n3201\n0.0e+00\n0.09071787\nsmall\n\n\nHOGENOM\nPLAZA\n3257\n3503\n3.0e-03\n0.03402611\nsmall\n\n\nOrthoDB\nPLAZA\n3201\n3503\n7.0e-10\n0.07526911\nsmall\n\n\n\n\n\nWe can see that there are diffences in mean. In summary:\n\neggNOG orthogroups have lower scores than every other source\nHOGENOM orthogroups have higher scores than OrthoDB, but lower than PLAZA.\nPLAZA orthogroup scores are higher than every other database.\n\nHowever, the effect sizes are very small, suggesting that significant differences could be due to large sample sizes, as P-values are highly affected by sample sizes.\nNow, let’s visualize the distributions with significant differences highlighted. Here, we will only display comparison bars for comparisons with P &lt; 0.05 and effect sizes &gt; 0.1.\n\n# Comparisons to be made\ncomps &lt;- list(\n    c(\"HOGENOM\", \"eggNOG\")\n)\n\n# Change order of levels according to comparison results\nH_combined$Source &lt;- factor(\n    H_combined$Source, levels = rev(c(\n        \"PLAZA\", \"HOGENOM\", \"OrthoDB\", \"eggNOG\"\n    ))\n)\n\n# Visualize distributions with significant differences highlighted\ndistros &lt;- ggviolin(\n    H_combined, y = \"Score\", x = \"Source\", \n    orientation = \"horiz\", trim = TRUE, add = c(\"boxplot\", \"mean\"), \n    fill = \"Source\", add.params = list(fill = \"white\"), palette = \"jama\"\n) +\n    ggpubr::stat_compare_means(\n        comparisons = comps,\n        label = \"p.signif\",\n        method = \"wilcox.test\"\n    ) +\n    theme(legend.position = \"none\") +\n    labs(y = \"Scaled homogeneity scores\", x = \"Source of orthogroups\",\n         title = \"Distribution of mean homogeneity scores for orthogroups\",\n         subtitle = \"Scores were calculated based on *A. thaliana* genes\") +\n    theme(plot.subtitle = ggtext::element_markdown())\n\ndistros\n\n\n\n\nDistribution of mean orthogroup scores.\n\n\n\n\nTo conclude, despite some significant differences, all databases perform equally well in their orthogroup definition. The observed differences in means could be due to large sample sizes, as indicated by very low effect sizes, and to the different species composition of the database."
  },
  {
    "objectID": "chapters/03_orthogroup_inference_dbs.html#session-info",
    "href": "chapters/03_orthogroup_inference_dbs.html#session-info",
    "title": "3  Assessing orthogroup inference in public databases",
    "section": "Session info",
    "text": "Session info\nThis document was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.0 (2023-04-21)\n os       Ubuntu 20.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2023-08-07\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package          * version   date (UTC) lib source\n abind              1.4-5     2016-07-21 [1] CRAN (R 4.3.0)\n ape                5.7-1     2023-03-13 [1] CRAN (R 4.3.0)\n aplot              0.1.10    2023-03-08 [1] CRAN (R 4.3.0)\n backports          1.4.1     2021-12-13 [1] CRAN (R 4.3.0)\n beeswarm           0.4.0     2021-06-01 [1] CRAN (R 4.3.0)\n BiocGenerics       0.46.0    2023-04-25 [1] Bioconductor\n BiocManager        1.30.21.1 2023-07-18 [1] CRAN (R 4.3.0)\n BiocStyle          2.29.1    2023-08-04 [1] Github (Bioconductor/BiocStyle@7c0e093)\n Biostrings         2.68.0    2023-04-25 [1] Bioconductor\n bit                4.0.5     2022-11-15 [1] CRAN (R 4.3.0)\n bit64              4.0.5     2020-08-30 [1] CRAN (R 4.3.0)\n bitops             1.0-7     2021-04-24 [1] CRAN (R 4.3.0)\n broom              1.0.4     2023-03-11 [1] CRAN (R 4.3.0)\n car                3.1-2     2023-03-30 [1] CRAN (R 4.3.0)\n carData            3.0-5     2022-01-06 [1] CRAN (R 4.3.0)\n cli                3.6.1     2023-03-23 [1] CRAN (R 4.3.0)\n codetools          0.2-19    2023-02-01 [4] CRAN (R 4.2.2)\n cogeqc           * 1.4.0     2023-04-25 [1] Bioconductor\n coin               1.4-2     2021-10-08 [1] CRAN (R 4.3.0)\n colorspace         2.1-0     2023-01-23 [1] CRAN (R 4.3.0)\n commonmark         1.9.0     2023-03-17 [1] CRAN (R 4.3.0)\n crayon             1.5.2     2022-09-29 [1] CRAN (R 4.3.0)\n curl               5.0.0     2023-01-12 [1] CRAN (R 4.3.0)\n digest             0.6.33    2023-07-07 [1] CRAN (R 4.3.0)\n dplyr            * 1.1.2     2023-04-20 [1] CRAN (R 4.3.0)\n evaluate           0.21      2023-05-05 [1] CRAN (R 4.3.0)\n fansi              1.0.4     2023-01-22 [1] CRAN (R 4.3.0)\n farver             2.1.1     2022-07-06 [1] CRAN (R 4.3.0)\n fastmap            1.1.1     2023-02-24 [1] CRAN (R 4.3.0)\n forcats          * 1.0.0     2023-01-29 [1] CRAN (R 4.3.0)\n generics           0.1.3     2022-07-05 [1] CRAN (R 4.3.0)\n GenomeInfoDb       1.36.0    2023-04-25 [1] Bioconductor\n GenomeInfoDbData   1.2.10    2023-04-28 [1] Bioconductor\n ggbeeswarm         0.7.2     2023-04-29 [1] CRAN (R 4.3.0)\n ggfun              0.0.9     2022-11-21 [1] CRAN (R 4.3.0)\n ggplot2          * 3.4.1     2023-02-10 [1] CRAN (R 4.3.0)\n ggplotify          0.1.0     2021-09-02 [1] CRAN (R 4.3.0)\n ggpubr           * 0.6.0     2023-02-10 [1] CRAN (R 4.3.0)\n ggsci              3.0.0     2023-03-08 [1] CRAN (R 4.3.0)\n ggsignif           0.6.4     2022-10-13 [1] CRAN (R 4.3.0)\n ggtext             0.1.2     2022-09-16 [1] CRAN (R 4.3.0)\n ggtree             3.8.0     2023-04-25 [1] Bioconductor\n glue               1.6.2     2022-02-24 [1] CRAN (R 4.3.0)\n gridGraphics       0.5-1     2020-12-13 [1] CRAN (R 4.3.0)\n gridtext           0.1.5     2022-09-16 [1] CRAN (R 4.3.0)\n gtable             0.3.3     2023-03-21 [1] CRAN (R 4.3.0)\n here             * 1.0.1     2020-12-13 [1] CRAN (R 4.3.0)\n hms                1.1.3     2023-03-21 [1] CRAN (R 4.3.0)\n htmltools          0.5.5     2023-03-23 [1] CRAN (R 4.3.0)\n htmlwidgets        1.6.2     2023-03-17 [1] CRAN (R 4.3.0)\n igraph             1.4.2     2023-04-07 [1] CRAN (R 4.3.0)\n IRanges            2.34.0    2023-04-25 [1] Bioconductor\n jsonlite           1.8.7     2023-06-29 [1] CRAN (R 4.3.0)\n knitr              1.43      2023-05-25 [1] CRAN (R 4.3.0)\n labeling           0.4.2     2020-10-20 [1] CRAN (R 4.3.0)\n lattice            0.20-45   2021-09-22 [4] CRAN (R 4.2.0)\n lazyeval           0.2.2     2019-03-15 [1] CRAN (R 4.3.0)\n libcoin            1.0-9     2021-09-27 [1] CRAN (R 4.3.0)\n lifecycle          1.0.3     2022-10-07 [1] CRAN (R 4.3.0)\n lubridate        * 1.9.2     2023-02-10 [1] CRAN (R 4.3.0)\n magrittr           2.0.3     2022-03-30 [1] CRAN (R 4.3.0)\n markdown           1.6       2023-04-07 [1] CRAN (R 4.3.0)\n MASS               7.3-58.2  2023-01-23 [4] CRAN (R 4.2.2)\n Matrix             1.5-1     2022-09-13 [4] CRAN (R 4.2.1)\n matrixStats        1.0.0     2023-06-02 [1] CRAN (R 4.3.0)\n modeltools         0.2-23    2020-03-05 [1] CRAN (R 4.3.0)\n multcomp           1.4-25    2023-06-20 [1] CRAN (R 4.3.0)\n munsell            0.5.0     2018-06-12 [1] CRAN (R 4.3.0)\n mvtnorm            1.1-3     2021-10-08 [1] CRAN (R 4.3.0)\n nlme               3.1-162   2023-01-31 [4] CRAN (R 4.2.2)\n patchwork          1.1.2     2022-08-19 [1] CRAN (R 4.3.0)\n pillar             1.9.0     2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig          2.0.3     2019-09-22 [1] CRAN (R 4.3.0)\n plyr               1.8.8     2022-11-11 [1] CRAN (R 4.3.0)\n purrr            * 1.0.1     2023-01-10 [1] CRAN (R 4.3.0)\n R6                 2.5.1     2021-08-19 [1] CRAN (R 4.3.0)\n Rcpp               1.0.10    2023-01-22 [1] CRAN (R 4.3.0)\n RCurl              1.98-1.12 2023-03-27 [1] CRAN (R 4.3.0)\n readr            * 2.1.4     2023-02-10 [1] CRAN (R 4.3.0)\n reshape2           1.4.4     2020-04-09 [1] CRAN (R 4.3.0)\n rlang              1.1.1     2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown          2.23      2023-07-01 [1] CRAN (R 4.3.0)\n rprojroot          2.0.3     2022-04-02 [1] CRAN (R 4.3.0)\n rstatix            0.7.2     2023-02-01 [1] CRAN (R 4.3.0)\n rstudioapi         0.14      2022-08-22 [1] CRAN (R 4.3.0)\n S4Vectors          0.38.0    2023-04-25 [1] Bioconductor\n sandwich           3.0-2     2022-06-15 [1] CRAN (R 4.3.0)\n scales             1.2.1     2022-08-20 [1] CRAN (R 4.3.0)\n sessioninfo        1.2.2     2021-12-06 [1] CRAN (R 4.3.0)\n stringi            1.7.12    2023-01-11 [1] CRAN (R 4.3.0)\n stringr          * 1.5.0     2022-12-02 [1] CRAN (R 4.3.0)\n survival           3.5-3     2023-02-12 [4] CRAN (R 4.2.2)\n TH.data            1.1-2     2023-04-17 [1] CRAN (R 4.3.0)\n tibble           * 3.2.1     2023-03-20 [1] CRAN (R 4.3.0)\n tidyr            * 1.3.0     2023-01-24 [1] CRAN (R 4.3.0)\n tidyselect         1.2.0     2022-10-10 [1] CRAN (R 4.3.0)\n tidytree           0.4.2     2022-12-18 [1] CRAN (R 4.3.0)\n tidyverse        * 2.0.0     2023-02-22 [1] CRAN (R 4.3.0)\n timechange         0.2.0     2023-01-11 [1] CRAN (R 4.3.0)\n treeio             1.24.1    2023-05-31 [1] Bioconductor\n tzdb               0.3.0     2022-03-28 [1] CRAN (R 4.3.0)\n utf8               1.2.3     2023-01-31 [1] CRAN (R 4.3.0)\n vctrs              0.6.3     2023-06-14 [1] CRAN (R 4.3.0)\n vipor              0.4.5     2017-03-22 [1] CRAN (R 4.3.0)\n vroom              1.6.3     2023-04-28 [1] CRAN (R 4.3.0)\n withr              2.5.0     2022-03-03 [1] CRAN (R 4.3.0)\n xfun               0.39      2023-04-20 [1] CRAN (R 4.3.0)\n xml2               1.3.4     2023-04-27 [1] CRAN (R 4.3.0)\n XVector            0.40.0    2023-04-25 [1] Bioconductor\n yaml               2.3.7     2023-01-23 [1] CRAN (R 4.3.0)\n yulab.utils        0.0.6     2022-12-20 [1] CRAN (R 4.3.0)\n zlibbioc           1.46.0    2023-04-25 [1] Bioconductor\n zoo                1.8-12    2023-04-13 [1] CRAN (R 4.3.0)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "chapters/03_orthogroup_inference_dbs.html#references",
    "href": "chapters/03_orthogroup_inference_dbs.html#references",
    "title": "3  Assessing orthogroup inference in public databases",
    "section": "References",
    "text": "References\n\n\n\n\nConsortium, The UniProt. 2021. “UniProt: The Universal Protein Knowledgebase in 2021.” Nucleic Acids Research 49 (D1): D480–89.\n\n\nHernandez-Plaza, Ana, Damian Szklarczyk, Jorge Botas, Carlos P Cantalapiedra, Joaquin Giner-Lamia, Daniel R Mende, Rebecca Kirsch, et al. 2023. “eggNOG 6.0: Enabling Comparative Genomics Across 12 535 Organisms.” Nucleic Acids Research 51 (D1): D389–94.\n\n\nKuznetsov, Dmitry, Fredrik Tegenfeldt, Mose Manni, Mathieu Seppey, Matthew Berkeley, Evgenia V Kriventseva, and Evgeny M Zdobnov. 2023. “OrthoDB V11: Annotation of Orthologs in the Widest Sampling of Organismal Diversity.” Nucleic Acids Research 51 (D1): D445–51.\n\n\nPenel, Simon, Anne-Muriel Arigon, Jean-François Dufayard, Anne-Sophie Sertier, Vincent Daubin, Laurent Duret, Manolo Gouy, and Guy Perrière. 2009. “Databases of Homologous Gene Families for Comparative Genomics.” In BMC Bioinformatics, 10:1–13. 6. BioMed Central.\n\n\nVan Bel, Michiel, Francesca Silvestri, Eric M Weitz, Lukasz Kreft, Alexander Botzki, Frederik Coppens, and Klaas Vandepoele. 2022. “PLAZA 5.0: Extending the Scope and Power of Comparative and Functional Genomics in Plants.” Nucleic Acids Research 50 (D1): D1468–74."
  },
  {
    "objectID": "chapters/04_orthogroup_inference_brassicaceae.html#orthogroup-inference",
    "href": "chapters/04_orthogroup_inference_brassicaceae.html#orthogroup-inference",
    "title": "4  Assessing orthogroup inference for Brassicaceae genomes",
    "section": "4.1 Orthogroup inference",
    "text": "4.1 Orthogroup inference\nTo start, we will load the proteome data and export each proteome as a FASTA file in the data directory, so we can pass it to OrthoFinder.\n\n# Load proteomes\nload(here(\"data\", \"brassicaceae_proteomes.rda\"))\n\n# Write files to data/\nlapply(seq_along(brassicaceae_proteomes), function(x) {\n    outfile &lt;- here(\"data\", paste0(names(brassicaceae_proteomes)[x], \".fasta\"))\n    Biostrings::writeXStringSet(\n        brassicaceae_proteomes[[x]], outfile\n    )\n})\n\nNow, we can run OrthoFinder for each combination of parameters. Here, we created 2 different bash scripts for each DIAMOND mode. They are:\n\nof_diamond.sh: code to run DIAMOND (default mode) for different inflation parameters;\nof_diamond_ultra.sh: code to run DIAMOND in ultrasensitive mode for different inflation parameters\n\nThe 2 files can be run with:\n\nbash of_diamond.sh\nbash of_diamond_ultra.sh\n\nThe Orthogroups.tsv files were all moved to the directory products/result_files."
  },
  {
    "objectID": "chapters/04_orthogroup_inference_brassicaceae.html#exploratory-analysis-of-orthogroup-inference-results",
    "href": "chapters/04_orthogroup_inference_brassicaceae.html#exploratory-analysis-of-orthogroup-inference-results",
    "title": "4  Assessing orthogroup inference for Brassicaceae genomes",
    "section": "4.2 Exploratory analysis of orthogroup inference results",
    "text": "4.2 Exploratory analysis of orthogroup inference results\nNow that we have the Orthogroups.tsv files from OrthoFinder, let’s load them.\n\n# Extract tar.xz file\ntarfile &lt;- here(\"products\", \"result_files\", \"Orthogroups.tar.xz\")\noutdir &lt;- tempdir()\n\nsystem2(\"tar\", args = c(\"-xf\", tarfile, \"--directory\", outdir))\n\n# Get path to OrthoFinder output\nog_files &lt;- list.files(\n    path = outdir, \n    pattern = \"Orthogroups.*\", full.names = TRUE\n)\n\n# Read and parse files\nogs &lt;- lapply(og_files, function(x) {\n    og &lt;- read_orthogroups(x)\n    og &lt;- og %&gt;%\n        mutate(Species = stringr::str_replace_all(Species, \"\\\\.\", \"\")) %&gt;%\n        mutate(Gene = str_replace_all(\n            Gene, c(\n                \"\\\\.[0-9]$\" = \"\",\n                \"\\\\.[0-9]\\\\.p$\" = \"\",\n                \"\\\\.t[0-9]$\" = \"\",\n                \"\\\\.g$\" = \"\"\n            )\n        ))\n    return(og)\n})\nog_names &lt;- gsub(\"\\\\.tsv\", \"\", basename(og_files))\nog_names &lt;- gsub(\"Orthogroups_\", \"\", og_names)\n\nnames(ogs) &lt;- og_names\n\nLet’s explore OG sizes for each combination of parameters and filter orthogroups by size to remove orthogroups that are artificially large.\n\n# Visualize OG sizes\nog_sizes_plot &lt;- patchwork::wrap_plots(\n    plot_og_sizes(ogs$default_1) + ggtitle(\"Default, mcl = 1\"), \n    plot_og_sizes(ogs$default_1_5) + ggtitle(\"Default, mcl = 1.5\") +\n        theme(axis.text.y = element_blank()),\n    plot_og_sizes(ogs$default_2) + ggtitle(\"Default, mcl = 2\") +\n        theme(axis.text.y = element_blank()), \n    plot_og_sizes(ogs$default_3) + ggtitle(\"Default, mcl = 3\") +\n        theme(axis.text.y = element_blank()),\n    plot_og_sizes(ogs$ultra_1) + ggtitle(\"Ultra, mcl = 1\") +\n        theme(axis.text.y = element_blank()), \n    plot_og_sizes(ogs$ultra_1_5) + ggtitle(\"Ultra, mcl = 1.5\") +\n        theme(axis.text.y = element_blank()),\n    plot_og_sizes(ogs$ultra_2) + ggtitle(\"Ultra, mcl = 2\") +\n        theme(axis.text.y = element_blank()), \n    plot_og_sizes(ogs$ultra_3) + ggtitle(\"Ultra, mcl = 3\") +\n        theme(axis.text.y = element_blank()),\n    nrow = 1, ncol = 8\n)\n\nog_sizes_plot\n\n\n\n\n\n\nOrthogroup sizes for each run.\n\n\n\n\nExpectedly, OrthoFinder runs with mcl inflation parameters of 1 lead to very large orthogroups, including some orthogroups with thousands of genes.\nNow, let’s explore the percentage of orthogroups with &gt;200, &gt;100, and &gt;50 genes in each OrthoFinder run.\n\n# Calculate OG sizes for each run\nog_sizes &lt;- lapply(ogs, function(x) {\n    sizes &lt;- as.matrix(table(x$Orthogroup, x$Species))\n    total &lt;- rowSums(sizes)\n    \n    sizes_df &lt;- data.frame(unclass(sizes))\n    sizes_df$Total &lt;- total\n    return(sizes_df)\n})\n\n# What is the percentage of OGs with &gt;=100 genes? And with &gt;50 genes?\npercentage_size &lt;- function(size_df, n = 100) {\n    return(sum(size_df$Total &gt; n) / nrow(size_df) * 100)\n}\n\npercentages &lt;- data.frame(\n    Mode = names(og_sizes),\n    P200 = unlist(lapply(og_sizes, percentage_size, n = 200)),\n    P100 = unlist(lapply(og_sizes, percentage_size, n = 100)),\n    P50 = unlist(lapply(og_sizes, percentage_size, n = 50)),\n    OGs = unlist(lapply(og_sizes, nrow))\n)\n\n# Reorder rows from lowest to highest mcl inflation\norders &lt;- c(\n    \"default_1\", \"default_1_5\", \"default_2\", \"default_3\",\n    \"ultra_1\", \"ultra_1_5\", \"ultra_2\", \"ultra_3\"\n)\npercentages &lt;- percentages[orders, ]\n\n# Visual exploration\npercentage_plot &lt;- percentages %&gt;%\n    tidyr::pivot_longer(cols = !Mode) %&gt;%\n    mutate(name = str_replace_all(\n        name,\n        c(\n            \"OGs\" = \"Number of OGs\",\n            \"P200\" = \"% OGs with &gt;200 genes\",\n            \"P100\" = \"% OGs with &gt;100 genes\",\n            \"P50\" = \"% OGs with &gt;50 genes\"\n        )\n    )) %&gt;%\n    ggplot(., aes(y = Mode, x = value)) +\n    geom_col(aes(fill = Mode), show.legend = \"none\") +\n    scale_fill_manual(\n        values = c(\"ultra_3\" = \"#08519C\", \"ultra_2\" = \"#3182BD\",\n                   \"ultra_1_5\" = \"#6BAED6\", \"ultra_1\" = \"#BDD7E7\",\n                   \"default_3\" = \"#006D2C\", \"default_2\" = \"#31A354\",\n                   \"default_1_5\" = \"#74C476\", \"default_1\" = \"#BAE4B3\")\n    ) +\n    facet_wrap(~name, ncol = 4, scales = \"free_x\") +\n    theme_bw() +\n    labs(\n        x = \"\", y = \"OrthoFinder mode\",\n        title = \"Relationship between the number of orthogroups and orthogroup size per OrthoFinder mode\"\n    )\n\npercentage_plot\n\nIt is very clear that increasing the mcl inflation increases the number of orthogroups, but decreases the percentage of OGs with more than 100 and 50 genes.\nFinally, let’s remove OGs with &gt;=200 genes to remove noise.\n\n# Filter OGs\nogs_filtered &lt;- lapply(seq_along(ogs), function(x) {\n    \n    # Which OGs less than 200 genes?\n    og_keep &lt;- rownames(og_sizes[[x]][og_sizes[[x]]$Total &lt; 200, ])\n    \n    fogs &lt;- ogs[[x]][ogs[[x]]$Orthogroup %in% og_keep, ]\n    return(fogs)\n})\nnames(ogs_filtered) &lt;- names(ogs)"
  },
  {
    "objectID": "chapters/04_orthogroup_inference_brassicaceae.html#orthogroup-assessment",
    "href": "chapters/04_orthogroup_inference_brassicaceae.html#orthogroup-assessment",
    "title": "4  Assessing orthogroup inference for Brassicaceae genomes",
    "section": "4.3 Orthogroup assessment",
    "text": "4.3 Orthogroup assessment\nNow, let’s get InterPro domain annotation for the following species to assess orthogroups:\n\nA. thaliana\nA. arabicum\nA. lyrata\nB. carinata\nC. rubella\nC. hirsuta\nS. parvula\n\n\n# Define function to read functional annotation from PLAZA 5.0\nread_annotation &lt;- function(url, cols = c(1, 3)) {\n    annot &lt;- readr::read_tsv(url, show_col_types = FALSE, skip = 8) %&gt;%\n        select(cols)\n    names(annot)[1:2] &lt;- c(\"Gene\", \"Annotation\")\n    return(annot)\n}\n\n\n# Get Interpro annotation\nbase &lt;- \"https://ftp.psb.ugent.be/pub/plaza/plaza_public_dicots_05/InterPro/\"\ninterpro &lt;- list(\n    Athaliana = read_annotation(paste0(base, \"interpro.ath.csv.gz\")),     \n    Aarabicum = read_annotation(paste0(base, \"interpro.aar.csv.gz\")),\n    Alyrata_cvMN47 = read_annotation(paste0(base, \"interpro.aly.csv.gz\")),\n    Bcarinata_cvzd1 = read_annotation(paste0(base, \"interpro.bca.csv.gz\")),\n    Crubella_cvMonteGargano = read_annotation(paste0(base, \"interpro.cru.csv.gz\")),\n    Chirsuta = read_annotation(paste0(base, \"interpro.chi.csv.gz\")),\n    Sparvula = read_annotation(paste0(base, \"interpro.spa.csv.gz\"))\n)\ninterpro &lt;- lapply(interpro, as.data.frame)\n\n# Calculate homogeneity scores\nspecies_annotation &lt;- names(interpro)\nog_assessment &lt;- lapply(seq_along(ogs_filtered), function(x) {\n    \n    message(\"Working on mode \", names(ogs_filtered)[x])\n    orthogroups &lt;- ogs_filtered[[x]]\n    orthogroups &lt;- orthogroups[orthogroups$Species %in% species_annotation, ]\n    \n    res &lt;- assess_orthogroups(orthogroups, interpro)\n    res$Mode &lt;- factor(\n        names(ogs_filtered)[x], \n        levels = c(\n            \"ultra_3\", \"ultra_2\", \"ultra_1_5\", \"ultra_1\",\n            \"default_3\", \"default_2\", \"default_1_5\", \"default_1\"\n        )\n    )\n    return(res)\n})\nog_assessment &lt;- Reduce(rbind, og_assessment)\n\n# Save homogeneity stats\nsave(\n    og_assessment, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"og_assessment_brassicaceae.rda\")\n)"
  },
  {
    "objectID": "chapters/04_orthogroup_inference_brassicaceae.html#comparing-and-visualizing-homogeneity-statistics",
    "href": "chapters/04_orthogroup_inference_brassicaceae.html#comparing-and-visualizing-homogeneity-statistics",
    "title": "4  Assessing orthogroup inference for Brassicaceae genomes",
    "section": "4.4 Comparing and visualizing homogeneity statistics",
    "text": "4.4 Comparing and visualizing homogeneity statistics\nHere, we will compare and visualize how the homogeneity scores are affected by:\n\ndifferent species choice\ndifferent mcl inflation values\ndifferent DIAMOND modes (default and ultra)\n\nQuick exploration of median and mean homogeneity:\n\nload(here(\"products\", \"result_files\", \"og_assessment_brassicaceae.rda\"))\n\n# Scale value to the maximum so that values range from 0 to 1\nog_assessment$Median_score &lt;- og_assessment$Median_score / \n    max(og_assessment$Median_score)\n\n# Mean\nmean_og &lt;- og_assessment %&gt;%\n    group_by(Mode) %&gt;%\n    summarise(mean = mean(Median_score))\n\n# Median\nmedian_og &lt;- og_assessment %&gt;%\n    group_by(Mode) %&gt;%\n    summarise(median = median(Median_score))\n\nmean_and_median_og &lt;- inner_join(mean_og, median_og) |&gt;\n    dplyr::rename(Mean = mean, Median = median)\n\nknitr::kable(mean_and_median_og, caption = \"Mean and median OG scores.\", digits = 3)\n\n\nMean and median OG scores.\n\n\nMode\nMean\nMedian\n\n\n\n\nultra_3\n0.640\n0.640\n\n\nultra_2\n0.631\n0.635\n\n\nultra_1_5\n0.620\n0.628\n\n\nultra_1\n0.425\n0.424\n\n\ndefault_3\n0.639\n0.640\n\n\ndefault_2\n0.631\n0.635\n\n\ndefault_1_5\n0.620\n0.628\n\n\ndefault_1\n0.425\n0.423\n\n\n\n\n\n\n4.4.1 Global distributions\nHere, we will compare and visualize all distros considering different DIAMOND modes and mcl inflation values. To start, let’s perform Wilcoxon tests for all combinations of modes and obtain effect sizes.\n\n# Relevel 'Mode' factor\nog_assessment$Mode &lt;- factor(\n    og_assessment$Mode, \n    levels = c(\n        \"ultra_3\", \"ultra_2\", \"ultra_1_5\", \"ultra_1\",\n        \"default_3\", \"default_2\", \"default_1_5\", \"default_1\"\n    )\n)\n\n# Comparing all vs all\ncomp_global &lt;- compare(og_assessment, \"Median_score ~ Mode\")\ncomp_global |&gt;\n    filter_comparison() |&gt;\n    knitr::kable(\n        caption = \"Mann-Whitney U test for differences in orthogroup scores with Wilcoxon effect sizes.\",\n        digits = 10\n    )\n\n\nMann-Whitney U test for differences in orthogroup scores with Wilcoxon effect sizes.\n\n\n\n\n\n\n\n\n\n\n\ngroup1\ngroup2\nn1\nn2\npadj\neffsize\nmagnitude\n\n\n\n\nultra_3\nultra_2\n19738\n18575\n0.00e+00\n0.04120347\nsmall\n\n\nultra_3\nultra_1_5\n19738\n16898\n0.00e+00\n0.06125964\nsmall\n\n\nultra_3\nultra_1\n19738\n5534\n0.00e+00\n0.34087185\nmoderate\n\n\nultra_3\ndefault_3\n19738\n19765\n5.00e-10\n0.03113134\nsmall\n\n\nultra_3\ndefault_2\n19738\n18633\n0.00e+00\n0.04197169\nsmall\n\n\nultra_3\ndefault_1_5\n19738\n16975\n0.00e+00\n0.06233198\nsmall\n\n\nultra_3\ndefault_1\n19738\n5587\n0.00e+00\n0.34258513\nmoderate\n\n\nultra_2\nultra_1_5\n18575\n16898\n0.00e+00\n0.04340346\nsmall\n\n\nultra_2\nultra_1\n18575\n5534\n0.00e+00\n0.33536590\nmoderate\n\n\nultra_2\ndefault_3\n18575\n19765\n0.00e+00\n0.04018176\nsmall\n\n\nultra_2\ndefault_2\n18575\n18633\n2.55e-08\n0.02855053\nsmall\n\n\nultra_2\ndefault_1_5\n18575\n16975\n0.00e+00\n0.04451653\nsmall\n\n\nultra_2\ndefault_1\n18575\n5587\n0.00e+00\n0.33742024\nmoderate\n\n\nultra_1_5\nultra_1\n16898\n5534\n0.00e+00\n0.32401575\nmoderate\n\n\nultra_1_5\ndefault_3\n16898\n19765\n0.00e+00\n0.05737302\nsmall\n\n\nultra_1_5\ndefault_2\n16898\n18633\n0.00e+00\n0.04259062\nsmall\n\n\nultra_1_5\ndefault_1_5\n16898\n16975\n1.72e-06\n0.02554732\nsmall\n\n\nultra_1_5\ndefault_1\n16898\n5587\n0.00e+00\n0.32541386\nmoderate\n\n\nultra_1\ndefault_3\n5534\n19765\n0.00e+00\n0.34014551\nmoderate\n\n\nultra_1\ndefault_2\n5534\n18633\n0.00e+00\n0.33456485\nmoderate\n\n\nultra_1\ndefault_1_5\n5534\n16975\n0.00e+00\n0.32260079\nmoderate\n\n\nultra_1\ndefault_1\n5534\n5587\n2.70e-02\n0.01928759\nsmall\n\n\ndefault_3\ndefault_2\n19765\n18633\n0.00e+00\n0.04084430\nsmall\n\n\ndefault_3\ndefault_1_5\n19765\n16975\n0.00e+00\n0.06124558\nsmall\n\n\ndefault_3\ndefault_1\n19765\n5587\n0.00e+00\n0.34147823\nmoderate\n\n\ndefault_2\ndefault_1_5\n18633\n16975\n0.00e+00\n0.04366051\nsmall\n\n\ndefault_2\ndefault_1\n18633\n5587\n0.00e+00\n0.33616829\nmoderate\n\n\ndefault_1_5\ndefault_1\n16975\n5587\n0.00e+00\n0.32420710\nmoderate\n\n\n\n\n\nAs we can see, using mcl = 1 leads to much smaller homogeneity scores as compared to every other mcl value. For mcl values &gt;=1.5, there are differences, but they are likely due to large sample sizes, as indicated by small effect sizes.\nThe default OrthoFinder mode (default DIAMOND, mcl = 1.5) leads to higher homogeneity as compared to runs using mcl = 1, both in default and ultrasensitive DIAMOND modes. The difference between the default mode and runs with higher mcl values are negligible.\nNow, let’s visualize the distributions and compare the default OrthoFinder mode with every other mode, highlighting significant differences (P &lt; 0.05) with effect size &gt; 0.1.\n\n# Visualize\nglobal_comps &lt;- list(\n    c(\"default_1_5\", \"ultra_1\"),\n    c(\"default_1_5\", \"default_1\")\n) \n\np_distros_global &lt;- ggviolin(\n    og_assessment, y = \"Median_score\", x = \"Mode\", \n    orientation = \"horiz\", trim = TRUE,\n    add = c(\"boxplot\", \"mean\"), \n    fill = \"Mode\", add.params = list(fill = \"white\")\n) +\n    scale_fill_manual(\n        values = c(\"ultra_3\" = \"#08519C\", \"ultra_2\" = \"#3182BD\",\n                   \"ultra_1_5\" = \"#6BAED6\", \"ultra_1\" = \"#BDD7E7\",\n                   \"default_3\" = \"#006D2C\", \"default_2\" = \"#31A354\",\n                   \"default_1_5\" = \"#74C476\", \"default_1\" = \"#BAE4B3\")\n    ) +\n    stat_compare_means(\n        comparisons = global_comps, label = \"p.signif\",\n        method = \"wilcox.test\"\n    ) +\n    theme(legend.position = \"none\") +\n    labs(y = \"Scaled homogeneity scores\", x = \"OrthoFinder modes\",\n         title = \"Distribution of mean homogeneity scores for orthogroups\") +\n    theme(plot.subtitle = ggtext::element_markdown())\n\np_distros_global\n\n\n\n\nDistribution of mean orthogroup scores for each OrthoFinder run.\n\n\n\n\n\n\n4.4.2 The effect of species choice\nHere, we will compare the distributions of orthogroups scores using each species individually to see if the species choice has an impact on the conclusions.\n\nog_species_long &lt;- Reduce(rbind, lapply(2:8, function(x) {\n    \n    var &lt;- names(og_assessment)[x]\n    species_name &lt;- gsub(\"_.*\", \"\", var)\n    \n    long_df &lt;- og_assessment[, c(\"Orthogroups\", var, \"Mode\")]\n    names(long_df) &lt;- c(\"OGs\", \"Score\", \"Mode\")\n    long_df$Score &lt;- long_df$Score / max(long_df$Score, na.rm = TRUE)\n    long_df$Species &lt;- species_name\n    \n    return(long_df)\n}))\n\nog_species_long &lt;- og_species_long[!is.na(og_species_long$Score), ]\nog_species_long &lt;- og_species_long |&gt;\n    mutate(\n        Species = str_replace_all(\n            Species, \n            c(\n                \"Aarabicum\" = \"A. arabicum\",\n                \"Alyrata\" = \"A. lyrata\",\n                \"Athaliana\" = \"A. thaliana\",\n                \"Bcarinata\" = \"B. carinata\",\n                \"Chirsuta\" = \"C. hirsuta\",\n                \"Crubella\" = \"C. rubella\",\n                \"Sparvula\" = \"S. parvula\"\n            )\n        )\n    )\n\n\np_distros_by_species &lt;- ggviolin(\n    og_species_long, \n    y = \"Score\", x = \"Mode\", \n    orientation = \"horiz\", trim = TRUE,\n    add = c(\"boxplot\", \"mean\"), facet.by = \"Species\", nrow = 1,\n    fill = \"Mode\", add.params = list(fill = \"white\")\n) +\n    scale_fill_manual(\n        values = c(\n            \"ultra_3\" = \"#08519C\", \"ultra_2\" = \"#3182BD\",\n            \"ultra_1_5\" = \"#6BAED6\", \"ultra_1\" = \"#BDD7E7\",\n            \"default_3\" = \"#006D2C\", \"default_2\" = \"#31A354\",\n            \"default_1_5\" = \"#74C476\", \"default_1\" = \"#BAE4B3\"\n        )\n    ) +\n    theme(legend.position = \"none\") +\n    labs(\n        y = \"Scaled homogeneity scores\", x = \"OrthoFinder modes\",\n        title = \"Distribution of OG scores for each species\"\n    ) +\n    scale_x_discrete(\n        labels = c(\n            \"default_1\" = \"Default, 1\",\n            \"default_1_5\" = \"Default, 1.5\",\n            \"default_2\" = \"Default, 2\",\n            \"default_3\" = \"Default, 3\",\n            \"ultra_1\" = \"Ultra, 1\",\n            \"ultra_1_5\" = \"Ultra, 1.5\",\n            \"ultra_2\" = \"Ultra, 2\",\n            \"ultra_3\" = \"Ultra, 3\"\n        )\n    ) +\n    theme(axis.text.x = element_text(angle = 60, vjust = 0.5))\n\np_distros_by_species\n\n\n\n\nDistribution of orthogroup scores for each OrthoFinder run calculated for each species separately.\n\n\n\n\nWe conclude that the species choice does not affect the comparisons of orthogroup scores among OrthoFinder runs.\n\n\n4.4.3 The effect of mcl inflation parameters\nHere, we will explore the impact of changing mcl inflation parameters in the homogeneity of orthogroups.\n\n# Process data to include information on DIAMOND mode and mcl\nog_modes &lt;- og_assessment %&gt;%\n    mutate(diamond = str_replace_all(Mode, \"_.*\", \"\")) %&gt;%\n    mutate(mcl = str_replace_all(Mode, c(\"default_\" = \"\", \"ultra_\" = \"\"))) %&gt;%\n    mutate(mcl = str_replace_all(mcl, \"_\", \".\")) %&gt;%\n    mutate(mcl = as.numeric(mcl))\n\n# Obtain P-values from Wilcoxon tests and effect sizes\ncomp_mcl_default &lt;- og_modes %&gt;% \n    filter(diamond == \"default\") %&gt;%\n    compare(., \"Median_score ~ mcl\")\n\ncomp_mcl_default |&gt;\n    filter_comparison() |&gt;\n    knitr::kable(\n        caption = \"Mann-Whitney U test for differences in orthogroup scores between runs with different mcl parameters and standard DIAMOND mode. Effect sizes represent Wilcoxon effect sizes.\",\n        digits = 10\n    )\n\n\nMann-Whitney U test for differences in orthogroup scores between runs with different mcl parameters and standard DIAMOND mode. Effect sizes represent Wilcoxon effect sizes.\n\n\ngroup1\ngroup2\nn1\nn2\npadj\neffsize\nmagnitude\n\n\n\n\n1\n1.5\n5587\n16975\n0\n0.32420710\nmoderate\n\n\n1\n2\n5587\n18633\n0\n0.33616829\nmoderate\n\n\n1\n3\n5587\n19765\n0\n0.34147823\nmoderate\n\n\n1.5\n2\n16975\n18633\n0\n0.04366051\nsmall\n\n\n1.5\n3\n16975\n19765\n0\n0.06124558\nsmall\n\n\n2\n3\n18633\n19765\n0\n0.04084430\nsmall\n\n\n\n\ncomp_mcl_ultra &lt;- og_modes %&gt;% \n    filter(diamond == \"ultra\") %&gt;%\n    compare(., \"Median_score ~ mcl\")\n\ncomp_mcl_ultra |&gt;\n    filter_comparison() |&gt;\n    knitr::kable(\n        caption = \"Mann-Whitney U test for differences in orthogroup scores between runs with different mcl parameters and ultra-sensitive DIAMOND mode. Effect sizes represent Wilcoxon effect sizes.\",\n        digits = 10\n    )\n\n\nMann-Whitney U test for differences in orthogroup scores between runs with different mcl parameters and ultra-sensitive DIAMOND mode. Effect sizes represent Wilcoxon effect sizes.\n\n\ngroup1\ngroup2\nn1\nn2\npadj\neffsize\nmagnitude\n\n\n\n\n1\n1.5\n5534\n16898\n0\n0.32401575\nmoderate\n\n\n1\n2\n5534\n18575\n0\n0.33536590\nmoderate\n\n\n1\n3\n5534\n19738\n0\n0.34087185\nmoderate\n\n\n1.5\n2\n16898\n18575\n0\n0.04340346\nsmall\n\n\n1.5\n3\n16898\n19738\n0\n0.06125964\nsmall\n\n\n2\n3\n18575\n19738\n0\n0.04120347\nsmall\n\n\n\n\n\nIn line with what we demonstrated in the global distributions, the Wilcoxon tests show that mcl = 1 leads to much lower homogeneity scores than all other mcl values, regardless of the DIAMOND mode. Additionally, increasing mcl values leads to increased homogeneity scores (i.e., homogeneity scores follow the order of mcl 3 &gt; 2 &gt; 1.5 &gt; 1), but differences among mcl values &gt;=1.5 are negligible, as indicated by small effect sizes. Thus, low P-values could be due to large sample sizes.\nNow, let’s visualize the distributions.\n\n# List of comparisons to be made\nmcl_comp &lt;- list(\n    c(\"1\", \"1.5\"), c(\"1\", \"2\"), c(\"1\", \"3\"), c(\"1.5\", \"3\")\n)\n\n# Plot\np_distros_mcl &lt;- og_assessment %&gt;%\n    mutate(diamond = str_replace_all(Mode, \"_.*\", \"\")) %&gt;%\n    mutate(mcl = str_replace_all(Mode, c(\"default_\" = \"\", \"ultra_\" = \"\"))) %&gt;%\n    mutate(mcl = str_replace_all(mcl, \"_\", \".\")) %&gt;%\n    mutate(mcl = as.numeric(mcl)) %&gt;%\n    ggviolin(., x = \"mcl\", y = \"Median_score\", trim = TRUE,\n             add = c(\"boxplot\", \"mean\"), facet.by = \"diamond\",\n             fill = \"Mode\", add.params = list(fill = \"white\")) +\n    theme(legend.position = \"none\") +\n    scale_fill_manual(\n        values = c(\"ultra_3\" = \"#08519C\", \"ultra_2\" = \"#3182BD\",\n                   \"ultra_1_5\" = \"#6BAED6\", \"ultra_1\" = \"#BDD7E7\",\n                   \"default_3\" = \"#006D2C\", \"default_2\" = \"#31A354\",\n                   \"default_1_5\" = \"#74C476\", \"default_1\" = \"#BAE4B3\")\n    ) +\n    stat_compare_means(\n        comparisons = mcl_comp, label = \"p.signif\",\n        method = \"wilcox.test\"\n    ) +\n    labs(\n        y = \"Scaled homogeneity scores\", x = \"MCL inflation parameters\",\n        title = \"Effect of MCL inflation values on orthogroup inference\",\n        subtitle = \"Panels represent DIAMOND sensitivity modes\"\n    )\n\np_distros_mcl\n\n\n\n\nEffect of MCL inflation values on orthogroup scores.\n\n\n\n\n\n\n4.4.4 The effect of DIAMOND mode (default vs ultra)\nHere, we will investigate whether changing the DIAMOND mode (default vs ultrasensitive) in OrthoFinder affects orthogroup homogeneity.\n\n# Compare median scores\nmcl1 &lt;- og_modes %&gt;% \n    filter(mcl == 1) %&gt;%\n    compare(., \"Median_score ~ diamond\") |&gt;\n    filter_comparison()\n\nmcl1_5 &lt;- og_modes %&gt;% \n    filter(mcl == 1.5) %&gt;%\n    compare(., \"Median_score ~ diamond\") |&gt;\n    filter_comparison()\n\nmcl2 &lt;- og_modes %&gt;% \n    filter(mcl == 2) %&gt;%\n    compare(., \"Median_score ~ diamond\") |&gt;\n    filter_comparison()\n\nmcl3 &lt;- og_modes %&gt;% \n    filter(mcl == 3) %&gt;%\n    compare(., \"Median_score ~ diamond\") |&gt;\n    filter_comparison()\n\nbind_rows(\n    mcl1 |&gt; mutate(mcl = 1),\n    mcl1_5 |&gt; mutate(mcl = 1.5), \n    mcl2 |&gt; mutate(mcl = 2), \n    mcl3 |&gt; mutate(mcl = 3)\n) |&gt;\n    knitr::kable(\n        caption = \"Mann-Whitney U test for differences in orthogroup scores between runs with different DIAMOND modes for each mcl value. Effect sizes represent Wilcoxon effect sizes.\",\n        digits = 10\n    )\n\n\nMann-Whitney U test for differences in orthogroup scores between runs with different DIAMOND modes for each mcl value. Effect sizes represent Wilcoxon effect sizes.\n\n\ngroup1\ngroup2\nn1\nn2\npadj\neffsize\nmagnitude\nmcl\n\n\n\n\ndefault\nultra\n5587\n5534\n2.10e-02\n0.01928759\nsmall\n1.0\n\n\ndefault\nultra\n16975\n16898\n1.29e-06\n0.02554732\nsmall\n1.5\n\n\ndefault\nultra\n18633\n18575\n1.82e-08\n0.02855053\nsmall\n2.0\n\n\ndefault\nultra\n19765\n19738\n3.00e-10\n0.03113134\nsmall\n3.0\n\n\n\n\n\nAgain, we can see that there are significant P-values, but very small effect sizes, indicating no difference resulting from the DIAMOND mode. Thus, users can run the default mode of DIAMOND, which is way faster, without any loss of biological signal for orthogroup inference.\nLet’s visualize the distributions.\n\n# Plot\np_distros_diamond &lt;- og_modes %&gt;%\n    ggviolin(., x = \"diamond\", y = \"Median_score\", trim = TRUE,\n             add = c(\"boxplot\", \"mean\"), facet.by = \"mcl\", ncol = 4,\n             fill = \"Mode\", add.params = list(fill = \"white\")) +\n    theme(legend.position = \"none\") +\n    scale_fill_manual(\n        values = c(\"ultra_3\" = \"#08519C\", \"ultra_2\" = \"#3182BD\",\n                   \"ultra_1_5\" = \"#6BAED6\", \"ultra_1\" = \"#BDD7E7\",\n                   \"default_3\" = \"#006D2C\", \"default_2\" = \"#31A354\",\n                   \"default_1_5\" = \"#74C476\", \"default_1\" = \"#BAE4B3\")\n    ) +\n    labs(y = \"Scaled homogeneity scores\", x = \"DIAMOND mode\",\n         title = \"Effect of DIAMOND sensitivity mode on orthogroup inference\",\n         subtitle = \"Panels represent MCL inflation parameters\") +\n    theme(plot.subtitle = ggtext::element_markdown())\n\np_distros_diamond\n\n\n\n\nEffect of DIAMOND mode on orthogroup scores."
  },
  {
    "objectID": "chapters/04_orthogroup_inference_brassicaceae.html#functional-analysis-of-homogeneous-and-heterogeneous-gene-families",
    "href": "chapters/04_orthogroup_inference_brassicaceae.html#functional-analysis-of-homogeneous-and-heterogeneous-gene-families",
    "title": "4  Assessing orthogroup inference for Brassicaceae genomes",
    "section": "4.5 Functional analysis of homogeneous and heterogeneous gene families",
    "text": "4.5 Functional analysis of homogeneous and heterogeneous gene families\nBy looking at the global distributions of homogeneity scores, we can see that all distributions have a similar shape. This pattern suggests that some gene families tend to be more homogeneous (scores close to 1), while others tend to include domains that are not shared by all members. The latter can be, for instance, rapidly evolving families that gain or lose domains at faster rates.\nTo explore what these groups of families contain, we will perform a functional enrichment analysis each group. First of anything, let’s plot the distribution for the default OrthoFinder mode and highlight the groups.\n\n# Plot distro with groups\np_distros_groups &lt;- og_assessment %&gt;%\n    filter(Mode == \"default_1_5\") %&gt;%\n    ggplot(aes(x = Median_score)) +\n    geom_density(fill = \"grey80\", color = \"black\") +\n    ggpubr::theme_pubr() +\n    labs(\n        y = \"Density\", x = \"Orthogroup scores\",\n        title = \"Distribution of mean homogeneity scores for orthogroups\",\n        subtitle = \"Scores for the default OrthoFinder mode\"\n    ) +\n    geom_vline(xintercept = 0.56, color = \"firebrick\", linetype = 2) +\n    geom_vline(xintercept = 0.87, color = \"firebrick\", linetype = 2)\n\np_distros_groups\n\n\n\n\nDistribution of mean homogeneity scores for orthogroups\n\n\n\n\nNow, let’s get vectors of genes in orthogroups from each of the groups highlighted in the figure above.\n\nspecies &lt;- c(\n    \"Athaliana\", \"Aarabicum\", \"Alyrata_cvMN47\", \"Bcarinata_cvzd1\",\n    \"Crubella_cvMonteGargano\", \"Chirsuta\", \"Sparvula\"\n)\n\n# Get genes and orthogroups (default mode)\ngenes_ogs &lt;- ogs_filtered$default_1_5\n\n# Keep only species for which we have functional annotation info\ngenes_ogs &lt;- genes_ogs[genes_ogs$Species %in% species, c(1, 3)]\n\n# Get background genes (all genes in OGs)\nbackground &lt;- genes_ogs$Gene\n\n# Find orthogroups for each group\n## G1: 0 - 0.56\ng1 &lt;- og_assessment %&gt;%\n    filter(Mode == \"default_1_5\") %&gt;%\n    mutate(Median_score = Median_score / max(Median_score)) %&gt;%\n    filter(Median_score &lt;= 0.56) %&gt;%\n    select(Orthogroups) %&gt;%\n    inner_join(., genes_ogs, by = c(\"Orthogroups\" = \"Orthogroup\")) %&gt;%\n    pull(Gene)\n\n## G2: 0.56 - 0.87\ng2 &lt;- og_assessment %&gt;%\n    filter(Mode == \"default_1_5\") %&gt;%\n    mutate(Median_score = Median_score / max(Median_score)) %&gt;%\n    filter(Median_score &gt; 0.56 & Median_score &lt;= 0.87) %&gt;%\n    select(Orthogroups) %&gt;%\n    inner_join(., genes_ogs, by = c(\"Orthogroups\" = \"Orthogroup\")) %&gt;%\n    pull(Gene)\n\n\n## G3: 0.87 - 1\ng3 &lt;- og_assessment %&gt;%\n    filter(Mode == \"default_1_5\") %&gt;%\n    mutate(Median_score = Median_score / max(Median_score)) %&gt;%\n    filter(Median_score &gt; 0.87) %&gt;%\n    select(Orthogroups) %&gt;%\n    inner_join(., genes_ogs, by = c(\"Orthogroups\" = \"Orthogroup\")) %&gt;%\n    pull(Gene)\n\nNext, we need to get functional annotation from PLAZA.\n\noptions(timeout = 6000)\nplaza_species &lt;- c(\"ath\", \"aar\", \"aly\", \"bca\", \"cru\", \"chi\", \"spa\")\n\n# GO annotation\nbgo &lt;- \"https://ftp.psb.ugent.be/pub/plaza/plaza_public_dicots_05/GO/\"\ngo &lt;- lapply(plaza_species, function(x) {\n    y &lt;- read_annotation(paste0(bgo, \"go.\", x, \".csv.gz\"), c(1, 3, 8))\n    term2gene &lt;- y[, c(2, 1)] %&gt;% distinct(., .keep_all = TRUE)\n    term2name &lt;- y[, c(2, 3)] %&gt;% distinct(., .keep_all = TRUE)\n    res &lt;- list(\n        TERM2GENE = as.data.frame(term2gene), \n        TERM2NAME = as.data.frame(term2name)\n    )\n    return(res)\n})\ngo_gene &lt;- Reduce(rbind, lapply(go, function(x) return(x$TERM2GENE)))\ngo_des &lt;- Reduce(rbind, lapply(go, function(x) return(x$TERM2NAME)))\n\n## Remove non-BP terms\nath_bp &lt;- file.path(tempdir(), \"ath_bp.rds\")\ndownload.file(\n    \"https://jokergoo.github.io/rGREAT_genesets/genesets/bp_athaliana_eg_gene_go_genesets.rds\",\n    destfile = ath_bp\n)\ngobp &lt;- readRDS(ath_bp)\ngobp &lt;- names(gobp)\ngo_gene &lt;- go_gene[go_gene$Annotation %in% gobp, ]\ngo_des &lt;- go_des[go_des$Annotation %in% gobp, ]\nrm(gobp)\n\n# MapMan annotation\nbmm &lt;- \"https://ftp.psb.ugent.be/pub/plaza/plaza_public_dicots_05/MapMan/\"\nmm &lt;- lapply(plaza_species, function(x) {\n    y &lt;- read_annotation(paste0(bmm, \"mapman.\", x, \".csv.gz\"), c(3:5))\n    term2gene &lt;- y[, c(2, 1)] %&gt;% distinct(., .keep_all = TRUE)\n    term2name &lt;- y[, c(2, 3)] %&gt;% distinct(., .keep_all = TRUE)\n    res &lt;- list(\n        TERM2GENE = as.data.frame(term2gene), \n        TERM2NAME = as.data.frame(term2name)\n    )\n    return(res)\n})\nmm_gene &lt;- Reduce(rbind, lapply(mm, function(x) return(x$TERM2GENE)))\nmm_des &lt;- Reduce(rbind, lapply(mm, function(x) return(x$TERM2NAME))) %&gt;%\n    mutate(desc = str_replace_all(desc, \".*\\\\.\", \"\"))\n\n# InterPro\nbi &lt;- \"https://ftp.psb.ugent.be/pub/plaza/plaza_public_dicots_05/InterPro/\"\nip &lt;- lapply(plaza_species, function(x) {\n    y &lt;- read_annotation(paste0(bi, \"interpro.\", x, \".csv.gz\"), c(1, 3, 4))\n    term2gene &lt;- y[, c(2, 1)] %&gt;% distinct(., .keep_all = TRUE)\n    term2name &lt;- y[, c(2, 3)] %&gt;% distinct(., .keep_all = TRUE)\n    res &lt;- list(\n        TERM2GENE = as.data.frame(term2gene), \n        TERM2NAME = as.data.frame(term2name)\n    )\n    return(res)\n})\nip_gene &lt;- Reduce(rbind, lapply(ip, function(x) return(x$TERM2GENE)))\nip_des &lt;- Reduce(rbind, lapply(ip, function(x) return(x$TERM2NAME)))\n\nNow, we can finally perform the enrichment analyses.\n\n# Perform enrichment analyses\nlibrary(clusterProfiler)\n\ntgene &lt;- list(\n    GO = go_gene, \n    MapMan = mm_gene,\n    InterPro = ip_gene\n)\ntname &lt;- list(\n    GO = go_des,\n    MapMan = mm_des,\n    InterPro = ip_des\n)\n\n## G1\ng1_sea &lt;- Reduce(rbind, lapply(seq_along(tgene), function(x) {\n    return(as.data.frame(enricher(\n        g1, universe = background, \n        TERM2GENE = tgene[[x]], TERM2NAME = tname[[x]]\n    ))[, 1:6])\n}))\n\n## G2\ng2_sea &lt;- Reduce(rbind, lapply(seq_along(tgene), function(x) {\n    return(as.data.frame(enricher(\n        g2, universe = background, \n        TERM2GENE = tgene[[x]], TERM2NAME = tname[[x]]\n    ))[, 1:6])\n}))\n\n## G3\ng3_sea &lt;- Reduce(rbind, lapply(seq_along(tgene), function(x) {\n    return(as.data.frame(enricher(\n        g3, universe = background, \n        TERM2GENE = tgene[[x]], TERM2NAME = tname[[x]]\n    ))[, 1:6])\n}))\n\n# Combine SEA results in a single data frame and export it as a .tsv file\n## Combine data frames\nsea_res &lt;- rbind(\n    g1_sea %&gt;% mutate(group = \"G1\"), \n    g2_sea %&gt;% mutate(group = \"G2\"),\n    g3_sea %&gt;% mutate(group = \"G3\")\n)\n\n## Export .tsv\nwrite_tsv(\n    sea_res,\n    file = here(\"products\", \"tables\", \"enrichment_bygroup.tsv\")\n)\n\nThe complete enrichment results are stored in the table enrichment_bygroup.tsv. To make visualization and interpretation easier, we will perform semantic similarity analysis to group redundant terms and get a global view of processes associated with each cluster.\nHere, we will only use GO terms from the category “Biological Process”.\n\n# Semantic similarity analysis for GO-BP terms\n## G1\ng1_summary &lt;- pairwise_termsim(enricher(\n    g1, universe = background, \n    TERM2GENE = go_gene, TERM2NAME = go_des\n))\n\n## G2\ng2_summary &lt;- pairwise_termsim(enricher(\n    g2, universe = background, \n    TERM2GENE = go_gene, TERM2NAME = go_des\n))\n\n## G3\ng3_summary &lt;- pairwise_termsim(enricher(\n    g3, universe = background, \n    TERM2GENE = go_gene, TERM2NAME = go_des\n))\n\n# Save objects\nsave(\n    g1_summary, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"g1_summary.rda\")\n)\n\nsave(\n    g2_summary, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"g2_summary.rda\")\n)\n\nsave(\n    g3_summary, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"g3_summary.rda\")\n)\n\nNow, let’s plot the results.\n\n# Tree plot\np_tree_g1 &lt;- treeplot(g1_summary, nWords = 0) +\n    ggsci::scale_fill_jama() +\n    ggtitle(\"Group 1\")\np_tree_g1$layers[[4]] &lt;- NULL\n\n\np_tree_g2 &lt;- treeplot(g2_summary, nCluster = 7, nWords = 0) +\n    ggsci::scale_fill_jama() +\n    ggtitle(\"Group 2\")\np_tree_g2$layers[[4]] &lt;- NULL\n\n\np_tree_g3 &lt;- treeplot(g3_summary, nWords = 0) +\n    ggsci::scale_fill_jama() +\n    ggtitle(\"Group 3\")\np_tree_g3$layers[[4]] &lt;- NULL\n\n\n# Replace P.adj with -log10(P.adj)\np_tree_g1$data$color &lt;- -log10(p_tree_g1$data$color)\np_tree_g2$data$color &lt;- -log10(p_tree_g2$data$color)\np_tree_g3$data$color &lt;- -log10(p_tree_g3$data$color)\n\n\n# Combine plots in one, with shared legends\nrcol &lt;- range(\n    c(\n        p_tree_g1$data$color, p_tree_g2$data$color, p_tree_g3$data$color\n    ),\n    na.rm = TRUE\n)\nrsize &lt;- range(\n    c(\n        p_tree_g1$data$count, p_tree_g2$data$count, p_tree_g2$data$count\n    ),\n    na.rm = TRUE\n)\n    \nwrap_plots(p_tree_g1, p_tree_g2, p_tree_g3) +\n    plot_layout(guides = \"collect\") &\n    scale_color_continuous(name = \"-Log10(P)\", limits = signif(rcol, 2)) &\n    scale_size_continuous(name = \"Gene count\", limits = rsize) &\n    theme(legend.position = \"bottom\")\n\n\n\n\nTree plot of functional terms associated with each orthogroup cluster.\n\n\n\n\n\n# Dot plot\np_dot_g1 &lt;- dotplot(g1_summary, showCategory = 20) + ggtitle(\"Group 1\")\np_dot_g2 &lt;- dotplot(g2_summary, showCategory = 20) + ggtitle(\"Group 2\")\np_dot_g3 &lt;- dotplot(g3_summary, showCategory = 20) + ggtitle(\"Group 3\")\n\n# Replace P.adj with -log10(P.adj)\np_dot_g1$data$p.adjust &lt;- -log10(p_dot_g1$data$p.adjust)\np_dot_g2$data$p.adjust &lt;- -log10(p_dot_g2$data$p.adjust)\np_dot_g3$data$p.adjust &lt;- -log10(p_dot_g3$data$p.adjust)\n\n# Combine plots in one, keep shared legend\nrcol &lt;- range(\n    c(\n        p_dot_g1$data$p.adjust, p_dot_g2$data$p.adjust, \n        p_dot_g3$data$p.adjust\n    ),\n    na.rm = TRUE\n)\nrsize &lt;- range(\n    c(\n        p_dot_g1$data$Count, p_dot_g2$data$Count, p_dot_g3$data$Count\n    ),\n    na.rm = TRUE\n)\n\nwrap_plots(p_dot_g1, p_dot_g2, p_dot_g3) +\n    plot_layout(guides = \"collect\") &\n    scale_color_continuous(name = \"-Log10(P)\", limits = signif(rcol, 2)) &\n    scale_size_continuous(name = \"Gene count\", limits = rsize) &\n    theme(legend.position = \"bottom\")\n\n\n\n\nDotplot of functional terms associated with each orthogroup cluster.\n\n\n\n\nThe plots show that genes associated to particular biological processes tend to be clustered in the same orthogroup (group 3, scores closer to 1), while genes associated to other biological processes tend to be more dispersed across orthogroups (groups 1 and 2, scores closer to 1), possibly because they are evolving faster and, hence, have lower sequence similarity among themselves. In details, these genes and processes are:\n\nGroup 1: ATP production, water and K+ transport, seed oilbody biogenesis, and response to nitrate and ethylene.\nGroup 2: sulfur amino acid metabolsm, spliceosome biogenesis, beta-1,3-glucan biosynthesis, response to brassinosteroids, xylem development, exocytosis, and calcium and sulfate transport.\nGroup 3: photosynthesis, zinc and amino acid transport, DNA replication, endocytosis, cell-cell junction assembly, and toxin catabolism."
  },
  {
    "objectID": "chapters/04_orthogroup_inference_brassicaceae.html#is-there-an-association-between-og-score-and-og-gene-length",
    "href": "chapters/04_orthogroup_inference_brassicaceae.html#is-there-an-association-between-og-score-and-og-gene-length",
    "title": "4  Assessing orthogroup inference for Brassicaceae genomes",
    "section": "4.6 Is there an association between OG score and OG gene length?",
    "text": "4.6 Is there an association between OG score and OG gene length?\nEmms and Kelly (2015) have demonstrated a gene length bias that influences the accuracy of orthogroup detection. This is because short sequences cannot produce large bit scores or low e-values, and long sequences produce many hits with scores better than those for the best hits of short sequences (Emms and Kelly 2015). OrthoFinder implements a score transform that claims to eliminate such bias. But does it remove the bias completely?\nTo answer this question, we will use homogeneity scores for the default OrthoFinder run (default DIAMOND mode, mcl = 1.5).\nFirst of all, let’s calculate the mean and median gene length for each orthogroup.\n\n# Combine proteomes into a single AAStringSet object and clean gene names\nnames(brassicaceae_proteomes) &lt;- NULL\nproteomes &lt;- do.call(c, brassicaceae_proteomes)\nrm(brassicaceae_proteomes)\n\nnames(proteomes) &lt;- gsub(\"\\\\\\t.*\", \"\", names(proteomes))\nnames(proteomes) &lt;- gsub(\" .*\", \"\", names(proteomes))\nnames(proteomes) &lt;- gsub(\"\\\\.[0-9]$\", \"\", names(proteomes))\nnames(proteomes) &lt;- gsub(\"\\\\.[0-9]\\\\.p$\", \"\", names(proteomes))\nnames(proteomes) &lt;- gsub(\"\\\\.t[0-9]$\", \"\", names(proteomes))\nnames(proteomes) &lt;- gsub(\"\\\\.g$\", \"\", names(proteomes))\n\n\n# Load only orthogroups from the default OrthoFinder run\nog &lt;- read_orthogroups(file.path(tempdir(), \"Orthogroups_default_1_5.tsv\")) %&gt;%\n    mutate(Gene = str_replace_all(\n        Gene, c(\n            \"\\\\\\t.*\" = \"\",\n            \"\\\\.[0-9]$\" = \"\",\n            \"\\\\.[0-9]\\\\.p$\" = \"\",\n            \"\\\\.t[0-9]$\" = \"\",\n            \"\\\\.g$\" = \"\"\n        )\n    )) %&gt;%\n    dplyr::select(Orthogroup, Gene)\n\n# Calculate mean gene lengths for each orthogroup\ngene_lengths &lt;- data.frame(\n    Gene = names(proteomes), \n    Length = Biostrings::width(proteomes)\n)\n\nog_gene_lengths &lt;- og %&gt;%\n    inner_join(., gene_lengths) %&gt;% \n    group_by(Orthogroup) %&gt;%\n    summarise(\n        mean_length = mean(Length),\n        median_length = median(Length)\n    )\n\n\n# Add homogeneity scores to data frame of mean gene length per orthogroup\nog_length_and_scores &lt;- og_assessment %&gt;%\n    dplyr::filter(Mode == \"default_1_5\") %&gt;%\n    dplyr::select(Orthogroups, Mean_H, Median_H) %&gt;%\n    inner_join(., og_gene_lengths, by = c(\"Orthogroups\" = \"Orthogroup\"))\n\nNow, since the number of domains in a protein correlates with its length, let’s also calculate the median number of domains in an orthogroup.\n\n# Calculate median number of domains for each orthogroup\nog_domain_count &lt;- Reduce(rbind, interpro) |&gt;\n    dplyr::count(Gene) |&gt;\n    inner_join(og, by = \"Gene\") |&gt;\n    group_by(Orthogroup) |&gt;\n    summarise(\n        median_ndomains = median(n)\n    )\n\nog_length_and_scores &lt;- left_join(\n    og_length_and_scores, og_domain_count, by = c(\"Orthogroups\" = \"Orthogroup\")\n)\n\n# Save data\nsave(\n    og_length_and_scores,\n    file = here(\"products\", \"result_files\", \"og_length_and_scores.rda\"),\n    compress = \"xz\"\n)\n\nNext, we will investigate if the number of domains can be a confounder in associations between the orthogroup score and gene length.\n\n# Explore associations between the number of domains and gene length\np_length_domains &lt;- ggplot(\n    og_length_and_scores, \n    aes(y = log2(median_ndomains + 1), x = log2(median_length + 1))\n) +\n    geom_point(alpha = 0.3) +\n    theme_bw() +\n    labs(\n        title = \"Number of domains and gene length\",\n        x = expression(Log[2] ~ \"median gene length\"),\n        y = expression(Log[2] ~ \"median number of domains\")\n    )\n\ncor_length_domains &lt;- cor.test(\n    log2(og_length_and_scores$median_length + 1), \n    log2(og_length_and_scores$median_ndomains + 1),\n    method = \"spearman\",\n    exact = FALSE\n)\n\n# Show plot and correlation test statistics\np_length_domains\n\n\n\ncor_length_domains\n\n\n    Spearman's rank correlation rho\n\ndata:  log2(og_length_and_scores$median_length + 1) and log2(og_length_and_scores$median_ndomains + 1)\nS = 4.7564e+11, p-value &lt; 2.2e-16\nalternative hypothesis: true rho is not equal to 0\nsample estimates:\n      rho \n0.4165488 \n\n\nThe figure and test above show that there is indeed a moderate correlation (\\(\\rho \\approx 0.4, P &lt;0.001\\)) between gene length and number of domains. Because of that, we will use partial Spearman’s correlation to measure the association between orthogroup scores and gene length while controlling for the number of domains.\n\n# Calculate partial Spearman's correlations\n## Without accounting for the number of domains\ncor1 &lt;- ppcor::pcor(\n    data.frame(\n        Length = log2(og_length_and_scores$median_length + 1), \n        Score = log2(og_length_and_scores$Median_H + 1)\n    ),\n    method = \"spearman\"\n)\ncor1\n\n$estimate\n           Length      Score\nLength  1.0000000 -0.1903208\nScore  -0.1903208  1.0000000\n\n$p.value\n              Length         Score\nLength  0.000000e+00 3.370622e-138\nScore  3.370622e-138  0.000000e+00\n\n$statistic\n          Length     Score\nLength   0.00000 -25.25673\nScore  -25.25673   0.00000\n\n$n\n[1] 16975\n\n$gp\n[1] 0\n\n$method\n[1] \"spearman\"\n\n## Accounting for the number of domains\ncor2 &lt;- ppcor::pcor.test(\n    log2(og_length_and_scores$median_length + 1), \n    log2(og_length_and_scores$Median_H + 1),\n    log2(og_length_and_scores$median_ndomains + 1),\n    method = \"spearman\"\n)\ncor2\n\n    estimate      p.value statistic     n gp   Method\n1 0.08593287 3.417431e-29  11.23661 16975  1 spearman\n\n\nThe tests show a weak correlation between orthogroup scores and gene length. When the number of domains is included as a covariate, we find no correlation at all, indicating that OrthoFinder’s normalization score is effective.\nFinally, let’s plot the data and add the test statistics.\n\np_association_length_homogeneity &lt;- og_length_and_scores %&gt;%\n    mutate(\n        logH = log10(Median_H + 1),\n        logLength = log10(median_length + 1)\n    ) %&gt;%\n    ggscatter(\n        ., x = \"logLength\", y = \"logH\", alpha = 0.3,\n        color = \"black\", size = 1\n    ) +\n    annotate(\n        \"text\",\n        x = 1.71, y = 0.055, \n        label = paste(\n            \"rho\", \"==\", signif(cor1$estimate[1, 2], 2)\n        ),\n        parse = TRUE\n    ) +\n    annotate(\n        \"text\",\n        x = 1.71, y = 0.035, \n        label = paste(\n            \"rho[partial]\", \"==\", signif(cor2$estimate, 2)\n        ),\n        parse = TRUE\n    ) +\n    annotate(\n        \"text\",\n        x = 1.71, y = 0.015,\n        label = paste(\"P\", \"&lt;\", 2.2e-16), parse = TRUE\n    ) +\n    labs(\n        title = \"Relationship between OG score and gene length\",\n        x = expression(Log[10] ~ \"median gene length\"),\n        y = expression(Log[10] ~ \"median homogeneity score\")\n    )\n\np_association_length_homogeneity\n\n\n\n\nRelationship between sequence length and orthogroup scores."
  },
  {
    "objectID": "chapters/04_orthogroup_inference_brassicaceae.html#session-info",
    "href": "chapters/04_orthogroup_inference_brassicaceae.html#session-info",
    "title": "4  Assessing orthogroup inference for Brassicaceae genomes",
    "section": "Session info",
    "text": "Session info\nThis document was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.0 (2023-04-21)\n os       Ubuntu 20.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2023-08-08\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package          * version   date (UTC) lib source\n abind              1.4-5     2016-07-21 [1] CRAN (R 4.3.0)\n AnnotationDbi      1.62.0    2023-04-25 [1] Bioconductor\n ape                5.7-1     2023-03-13 [1] CRAN (R 4.3.0)\n aplot              0.1.10    2023-03-08 [1] CRAN (R 4.3.0)\n backports          1.4.1     2021-12-13 [1] CRAN (R 4.3.0)\n beeswarm           0.4.0     2021-06-01 [1] CRAN (R 4.3.0)\n Biobase            2.60.0    2023-04-25 [1] Bioconductor\n BiocGenerics       0.46.0    2023-04-25 [1] Bioconductor\n BiocParallel       1.34.0    2023-04-25 [1] Bioconductor\n Biostrings         2.68.0    2023-04-25 [1] Bioconductor\n bit                4.0.5     2022-11-15 [1] CRAN (R 4.3.0)\n bit64              4.0.5     2020-08-30 [1] CRAN (R 4.3.0)\n bitops             1.0-7     2021-04-24 [1] CRAN (R 4.3.0)\n blob               1.2.4     2023-03-17 [1] CRAN (R 4.3.0)\n broom              1.0.4     2023-03-11 [1] CRAN (R 4.3.0)\n cachem             1.0.8     2023-05-01 [1] CRAN (R 4.3.0)\n car                3.1-2     2023-03-30 [1] CRAN (R 4.3.0)\n carData            3.0-5     2022-01-06 [1] CRAN (R 4.3.0)\n cli                3.6.1     2023-03-23 [1] CRAN (R 4.3.0)\n clusterProfiler  * 4.8.1     2023-05-03 [1] Bioconductor\n codetools          0.2-19    2023-02-01 [4] CRAN (R 4.2.2)\n cogeqc           * 1.4.0     2023-04-25 [1] Bioconductor\n coin               1.4-2     2021-10-08 [1] CRAN (R 4.3.0)\n colorspace         2.1-0     2023-01-23 [1] CRAN (R 4.3.0)\n commonmark         1.9.0     2023-03-17 [1] CRAN (R 4.3.0)\n cowplot            1.1.1     2020-12-30 [1] CRAN (R 4.3.0)\n crayon             1.5.2     2022-09-29 [1] CRAN (R 4.3.0)\n data.table         1.14.8    2023-02-17 [1] CRAN (R 4.3.0)\n DBI                1.1.3     2022-06-18 [1] CRAN (R 4.3.0)\n digest             0.6.33    2023-07-07 [1] CRAN (R 4.3.0)\n DOSE               3.26.1    2023-05-03 [1] Bioconductor\n downloader         0.4       2015-07-09 [1] CRAN (R 4.3.0)\n dplyr            * 1.1.2     2023-04-20 [1] CRAN (R 4.3.0)\n enrichplot       * 1.20.0    2023-04-25 [1] Bioconductor\n evaluate           0.21      2023-05-05 [1] CRAN (R 4.3.0)\n fansi              1.0.4     2023-01-22 [1] CRAN (R 4.3.0)\n farver             2.1.1     2022-07-06 [1] CRAN (R 4.3.0)\n fastmap            1.1.1     2023-02-24 [1] CRAN (R 4.3.0)\n fastmatch          1.1-3     2021-07-23 [1] CRAN (R 4.3.0)\n fgsea              1.26.0    2023-04-25 [1] Bioconductor\n forcats          * 1.0.0     2023-01-29 [1] CRAN (R 4.3.0)\n generics           0.1.3     2022-07-05 [1] CRAN (R 4.3.0)\n GenomeInfoDb       1.36.0    2023-04-25 [1] Bioconductor\n GenomeInfoDbData   1.2.10    2023-04-28 [1] Bioconductor\n ggbeeswarm         0.7.2     2023-04-29 [1] CRAN (R 4.3.0)\n ggforce            0.4.1     2022-10-04 [1] CRAN (R 4.3.0)\n ggfun              0.0.9     2022-11-21 [1] CRAN (R 4.3.0)\n ggnewscale         0.4.8     2022-10-06 [1] CRAN (R 4.3.0)\n ggplot2          * 3.4.1     2023-02-10 [1] CRAN (R 4.3.0)\n ggplotify          0.1.0     2021-09-02 [1] CRAN (R 4.3.0)\n ggpubr           * 0.6.0     2023-02-10 [1] CRAN (R 4.3.0)\n ggraph             2.1.0     2022-10-09 [1] CRAN (R 4.3.0)\n ggrepel            0.9.3     2023-02-03 [1] CRAN (R 4.3.0)\n ggsci              3.0.0     2023-03-08 [1] CRAN (R 4.3.0)\n ggsignif           0.6.4     2022-10-13 [1] CRAN (R 4.3.0)\n ggtext             0.1.2     2022-09-16 [1] CRAN (R 4.3.0)\n ggtree             3.8.0     2023-04-25 [1] Bioconductor\n glue               1.6.2     2022-02-24 [1] CRAN (R 4.3.0)\n GO.db              3.17.0    2023-05-02 [1] Bioconductor\n GOSemSim           2.26.0    2023-04-25 [1] Bioconductor\n graphlayouts       1.0.0     2023-05-01 [1] CRAN (R 4.3.0)\n gridExtra          2.3       2017-09-09 [1] CRAN (R 4.3.0)\n gridGraphics       0.5-1     2020-12-13 [1] CRAN (R 4.3.0)\n gridtext           0.1.5     2022-09-16 [1] CRAN (R 4.3.0)\n gson               0.1.0     2023-03-07 [1] CRAN (R 4.3.0)\n gtable             0.3.3     2023-03-21 [1] CRAN (R 4.3.0)\n HDO.db             0.99.1    2023-06-20 [1] Bioconductor\n here             * 1.0.1     2020-12-13 [1] CRAN (R 4.3.0)\n hms                1.1.3     2023-03-21 [1] CRAN (R 4.3.0)\n htmltools          0.5.5     2023-03-23 [1] CRAN (R 4.3.0)\n htmlwidgets        1.6.2     2023-03-17 [1] CRAN (R 4.3.0)\n httr               1.4.5     2023-02-24 [1] CRAN (R 4.3.0)\n igraph             1.4.2     2023-04-07 [1] CRAN (R 4.3.0)\n IRanges            2.34.0    2023-04-25 [1] Bioconductor\n jsonlite           1.8.7     2023-06-29 [1] CRAN (R 4.3.0)\n KEGGREST           1.40.0    2023-04-25 [1] Bioconductor\n knitr              1.43      2023-05-25 [1] CRAN (R 4.3.0)\n labeling           0.4.2     2020-10-20 [1] CRAN (R 4.3.0)\n lattice            0.20-45   2021-09-22 [4] CRAN (R 4.2.0)\n lazyeval           0.2.2     2019-03-15 [1] CRAN (R 4.3.0)\n libcoin            1.0-9     2021-09-27 [1] CRAN (R 4.3.0)\n lifecycle          1.0.3     2022-10-07 [1] CRAN (R 4.3.0)\n lubridate        * 1.9.2     2023-02-10 [1] CRAN (R 4.3.0)\n magrittr           2.0.3     2022-03-30 [1] CRAN (R 4.3.0)\n markdown           1.6       2023-04-07 [1] CRAN (R 4.3.0)\n MASS               7.3-58.2  2023-01-23 [4] CRAN (R 4.2.2)\n Matrix             1.5-1     2022-09-13 [4] CRAN (R 4.2.1)\n matrixStats        1.0.0     2023-06-02 [1] CRAN (R 4.3.0)\n memoise            2.0.1     2021-11-26 [1] CRAN (R 4.3.0)\n modeltools         0.2-23    2020-03-05 [1] CRAN (R 4.3.0)\n multcomp           1.4-25    2023-06-20 [1] CRAN (R 4.3.0)\n munsell            0.5.0     2018-06-12 [1] CRAN (R 4.3.0)\n mvtnorm            1.1-3     2021-10-08 [1] CRAN (R 4.3.0)\n nlme               3.1-162   2023-01-31 [4] CRAN (R 4.2.2)\n patchwork        * 1.1.2     2022-08-19 [1] CRAN (R 4.3.0)\n pillar             1.9.0     2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig          2.0.3     2019-09-22 [1] CRAN (R 4.3.0)\n plyr               1.8.8     2022-11-11 [1] CRAN (R 4.3.0)\n png                0.1-8     2022-11-29 [1] CRAN (R 4.3.0)\n polyclip           1.10-4    2022-10-20 [1] CRAN (R 4.3.0)\n ppcor              1.1       2015-12-03 [1] CRAN (R 4.3.0)\n purrr            * 1.0.1     2023-01-10 [1] CRAN (R 4.3.0)\n qvalue             2.32.0    2023-04-25 [1] Bioconductor\n R6                 2.5.1     2021-08-19 [1] CRAN (R 4.3.0)\n RColorBrewer       1.1-3     2022-04-03 [1] CRAN (R 4.3.0)\n Rcpp               1.0.10    2023-01-22 [1] CRAN (R 4.3.0)\n RCurl              1.98-1.12 2023-03-27 [1] CRAN (R 4.3.0)\n readr            * 2.1.4     2023-02-10 [1] CRAN (R 4.3.0)\n reshape2           1.4.4     2020-04-09 [1] CRAN (R 4.3.0)\n rlang              1.1.1     2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown          2.23      2023-07-01 [1] CRAN (R 4.3.0)\n rprojroot          2.0.3     2022-04-02 [1] CRAN (R 4.3.0)\n RSQLite            2.3.1     2023-04-03 [1] CRAN (R 4.3.0)\n rstatix          * 0.7.2     2023-02-01 [1] CRAN (R 4.3.0)\n rstudioapi         0.14      2022-08-22 [1] CRAN (R 4.3.0)\n S4Vectors          0.38.0    2023-04-25 [1] Bioconductor\n sandwich           3.0-2     2022-06-15 [1] CRAN (R 4.3.0)\n scales             1.2.1     2022-08-20 [1] CRAN (R 4.3.0)\n scatterpie         0.2.1     2023-06-07 [1] CRAN (R 4.3.0)\n sessioninfo        1.2.2     2021-12-06 [1] CRAN (R 4.3.0)\n shadowtext         0.1.2     2022-04-22 [1] CRAN (R 4.3.0)\n stringi            1.7.12    2023-01-11 [1] CRAN (R 4.3.0)\n stringr          * 1.5.0     2022-12-02 [1] CRAN (R 4.3.0)\n survival           3.5-3     2023-02-12 [4] CRAN (R 4.2.2)\n TH.data            1.1-2     2023-04-17 [1] CRAN (R 4.3.0)\n tibble           * 3.2.1     2023-03-20 [1] CRAN (R 4.3.0)\n tidygraph          1.2.3     2023-02-01 [1] CRAN (R 4.3.0)\n tidyr            * 1.3.0     2023-01-24 [1] CRAN (R 4.3.0)\n tidyselect         1.2.0     2022-10-10 [1] CRAN (R 4.3.0)\n tidytree           0.4.2     2022-12-18 [1] CRAN (R 4.3.0)\n tidyverse        * 2.0.0     2023-02-22 [1] CRAN (R 4.3.0)\n timechange         0.2.0     2023-01-11 [1] CRAN (R 4.3.0)\n treeio             1.24.1    2023-05-31 [1] Bioconductor\n tweenr             2.0.2     2022-09-06 [1] CRAN (R 4.3.0)\n tzdb               0.3.0     2022-03-28 [1] CRAN (R 4.3.0)\n utf8               1.2.3     2023-01-31 [1] CRAN (R 4.3.0)\n vctrs              0.6.3     2023-06-14 [1] CRAN (R 4.3.0)\n vipor              0.4.5     2017-03-22 [1] CRAN (R 4.3.0)\n viridis            0.6.2     2021-10-13 [1] CRAN (R 4.3.0)\n viridisLite        0.4.2     2023-05-02 [1] CRAN (R 4.3.0)\n withr              2.5.0     2022-03-03 [1] CRAN (R 4.3.0)\n xfun               0.39      2023-04-20 [1] CRAN (R 4.3.0)\n xml2               1.3.4     2023-04-27 [1] CRAN (R 4.3.0)\n XVector            0.40.0    2023-04-25 [1] Bioconductor\n yaml               2.3.7     2023-01-23 [1] CRAN (R 4.3.0)\n yulab.utils        0.0.6     2022-12-20 [1] CRAN (R 4.3.0)\n zlibbioc           1.46.0    2023-04-25 [1] Bioconductor\n zoo                1.8-12    2023-04-13 [1] CRAN (R 4.3.0)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "chapters/04_orthogroup_inference_brassicaceae.html#references",
    "href": "chapters/04_orthogroup_inference_brassicaceae.html#references",
    "title": "4  Assessing orthogroup inference for Brassicaceae genomes",
    "section": "References",
    "text": "References\n\n\n\n\nEmms, David M, and Steven Kelly. 2015. “OrthoFinder: Solving Fundamental Biases in Whole Genome Comparisons Dramatically Improves Orthogroup Inference Accuracy.” Genome Biology 16 (1): 1–14.\n\n\n———. 2019. “OrthoFinder: Phylogenetic Orthology Inference for Comparative Genomics.” Genome Biology 20 (1): 1–14."
  },
  {
    "objectID": "chapters/05_synteny_assessment_fabaceae.html#data-acquisition",
    "href": "chapters/05_synteny_assessment_fabaceae.html#data-acquisition",
    "title": "5  Assessing synteny detection in Fabaceae",
    "section": "5.1 Data acquisition",
    "text": "5.1 Data acquisition\nIn this section, we will download whole-genome protein sequences and gene annotation from PLAZA 5.0, and then we will preprocess the data with syntenet::process_input().\n\nspecies &lt;- c(\"mtr\", \"tpr\", \"psa\", \"car\", \"lja\", \"gma\", \"vmu\", \"lal\", \"arhy\")\n\n\nbase_url &lt;- \"https://ftp.psb.ugent.be/pub/plaza/plaza_public_dicots_05/\"\n\n# Get proteomes\nseq_url &lt;- paste0(\n    base_url, \"Fasta/proteome.selected_transcript.\", \n    species, \".fasta.gz\"\n)\n\n## Import files and clean gene IDs\nseq &lt;- lapply(seq_url, function(x) {\n    s &lt;- Biostrings::readAAStringSet(x)\n    names(s) &lt;- gsub(\".* | \", \"\", names(s))\n    return(s)\n})\nnames(seq) &lt;- species\n\n\n# Get gene annotation\nannot_url &lt;- paste0(\n    base_url, \"GFF/\", species, \"/annotation.selected_transcript.exon_features.\",\n    species, \".gff3.gz\"\n)\n\n## Import files and keep only relevant fields\nannot &lt;- lapply(annot_url, function(x) {\n    a &lt;- rtracklayer::import(x)\n    a &lt;- a[, c(\"type\", \"gene_id\")]\n    a &lt;- a[a$type == \"gene\"]\n    return(a)\n})\nnames(annot) &lt;- species\n\n# Process data\npdata &lt;- process_input(seq, annot)\n\n# Remove unprocessed data to clean the working environment\nrm(annot)\nrm(seq)"
  },
  {
    "objectID": "chapters/05_synteny_assessment_fabaceae.html#network-based-synteny-assessment",
    "href": "chapters/05_synteny_assessment_fabaceae.html#network-based-synteny-assessment",
    "title": "5  Assessing synteny detection in Fabaceae",
    "section": "5.2 Network-based synteny assessment",
    "text": "5.2 Network-based synteny assessment\nWe will infer synteny networks using the Bioconductor package syntenet. This package detects synteny using the MCScanX algorithm (Wang et al. 2012), which can produce different results based on 2 main parameters:\n\nanchors: minimum required number of genes to call a syntenic block. Default: 5.\nmax_gaps: number of upstream and downstream genes to search for anchors. Default: 25.\n\nWe will infer synteny networks with 5 combinations of parameters, similarly to Zhao and Schranz (2019), using two approaches:\n\nA single Fabaceae synteny network;\nSpecies-specific synteny networks for each Fabaceae species.\n\nTo start with, let’s define the combinations of parameters we will use.\n\n# Define combinations of parameters: anchors (a), max_gaps (m)\nsynteny_params &lt;- list(\n    c(3, 25),\n    c(5, 15),\n    c(5, 25),\n    c(5, 35),\n    c(7, 25)\n)\n\n\n5.2.1 Assessing the Fabaceae synteny network\nFirst, we will perform similarity searches with DIAMOND.\n\n# Define wrapper function to run DIAMOND with different top_hits\nout &lt;- file.path(tempdir(), \"diamond_all\")\nd5 &lt;- run_diamond(seq = seq, top_hits = 5, outdir = out)\n\nWith the DIAMOND list, we can detect synteny.\n\n# Define helper function to detect synteny with multiple combinations of params\nsynteny_wrapper &lt;- function(diamond, annotation, params) {\n    \n    syn &lt;- lapply(params, function(x) {\n        \n        anchors &lt;- x[1]\n        max_gaps &lt;- x[2]\n        outdir &lt;- file.path(tempdir(), paste0(\"syn_a\", anchors, \"_m\", max_gaps))\n        \n        s &lt;- infer_syntenet(\n            blast_list = diamond,\n            annotation = pdata$annotation,\n            outdir = outdir, \n            anchors = anchors,\n            max_gaps = max_gaps\n        )\n        return(s)\n    })\n    return(syn)\n}\n\n# Detect synteny\nsyn_fabaceae &lt;- synteny_wrapper(d5, pdata$annotation, synteny_params)\nnames(syn_fabaceae) &lt;- unlist(\n    lapply(synteny_params, function(x) paste0(\"a\", x[1], \"_m\", x[2]))\n)\n\nNow, let’s use the network-based synteny assessment to see which combination of parameters is the best.\n\n# Assess networks\nfabaceae_scores &lt;- assess_synnet_list(syn_fabaceae)\n\n# Look at scores, ranked from highest to lowest\nfabaceae_scores %&gt;%\n    arrange(-Score) |&gt;\n    knitr::kable(\n        caption = \"Scores for each synteny network.\"\n    )\n\n\nScores for each synteny network.\n\n\nCC\nNode_count\nRsquared\nScore\nNetwork\n\n\n\n\n0.8253002\n237723\n0.6227916\n122187.2\na3_m25\n\n\n0.8290880\n235290\n0.6156847\n120105.4\na5_m35\n\n\n0.8392223\n226657\n0.6026291\n114629.5\na5_m15\n\n\n0.8412602\n224325\n0.5972865\n112717.3\na7_m25\n\n\n0.8347725\n231820\n0.5795957\n112161.6\na5_m25\n\n\n\n\n\nAs we can see, the combination of parameters a = 3; m = 25 is the best for this data set.\nFinally, let’s visualize scores. To make visualization better, we will scale scores by the maximum value, so that values range from 0 to 1.\n\n# Plot scores\nsynteny_scores_fabaceae &lt;- fabaceae_scores %&gt;%\n    arrange(Score) %&gt;%\n    mutate(Score = Score / max(Score)) %&gt;%\n    mutate(Parameters = str_replace_all(Network, \"_\", \", \")) %&gt;%\n    mutate(Parameters = factor(Parameters, levels = unique(Parameters))) %&gt;%\n    ggplot(., aes(x = Parameters, y = Score)) +\n    geom_col(fill = \"grey60\", color = \"black\") +\n    theme_bw() +\n    labs(\n        title = \"Assessment of the Fabaceae synteny network\",\n        subtitle = \"a = minimum # of anchors; m = maximum # of gaps\",\n        y = \"Scaled score\"\n    )\n    \nsynteny_scores_fabaceae\n\n\n\n\nScaled scores for each synteny network.\n\n\n\n\n\n\n5.2.2 Assessing species-specific synteny networks\nIn this section, we will infer species-specific synteny networks and assess each of them with our network-based approach.\nThis time, as we already have synteny networks for the whole Fabaceae family, we don’t need to infer them again; we will simply subset edges of the network that contain nodes from the same species.\n\n# Create species-specific networks\nspecies_ids &lt;- substr(species, start = 1, stop = 3)\n\nspecies_networks &lt;- lapply(species_ids, function(x) {\n    \n    nets &lt;- lapply(syn_fabaceae, function(y) {\n        edges &lt;- y[startsWith(y$Anchor1, x) & startsWith(y$Anchor2, x), ]\n        return(edges)\n    })\n    return(nets)\n})\nnames(species_networks) &lt;- species_ids\n\n# Exploring data\nnames(species_networks)\n\n[1] \"mtr\" \"tpr\" \"psa\" \"car\" \"lja\" \"gma\" \"vmu\" \"lal\" \"arh\"\n\nnames(species_networks$mtr)\n\n[1] \"a3_m25\" \"a5_m15\" \"a5_m25\" \"a5_m35\" \"a7_m25\"\n\n# Rename `species_networks` to keep full name\nnames(species_networks) &lt;- c(\n    \"M. truncatula\", \"T. pratense\", \"P. sativum\", \"C. arietinum\",\n    \"L. japonicus\", \"G. max\", \"V. mungo\", \"L. albus\", \"A. hypogaea\"\n)\n\nFor each species, we will assess the networks inferred with different combinations of parameters.\n\n# Assess species-specific networks\nscores_species_nets &lt;- lapply(seq_along(species_networks), function(x) {\n    \n    species &lt;- names(species_networks)[x]\n    scores &lt;- assess_synnet_list(species_networks[[species]])\n    scores$Score[is.nan(scores$Score)] &lt;- 0\n    scores &lt;- scores[order(scores$Score, decreasing = TRUE), ]\n    scores$Species &lt;- species\n    scores$Score &lt;- scores$Score / max(scores$Score)\n    return(scores)\n})\nscores_species_nets &lt;- Reduce(rbind, scores_species_nets)\n\n# Plot data\nsynteny_scores_species &lt;- scores_species_nets %&gt;%\n    mutate(\n        Parameters = as.factor(str_replace_all(Network, \"_\", \", \")),\n        Species = as.factor(Species)\n    ) %&gt;%\n    mutate(Network = reorder_within(Parameters, Score, Species)) %&gt;%\n    ggplot(., aes(x = Network, y = Score, fill = Parameters)) +\n    geom_bar(stat = \"identity\", color = \"grey90\") +\n    facet_wrap(~Species, ncol = 3, scales = \"free\") +\n    scale_x_reordered() +\n    ggsci::scale_fill_jama() +\n    theme_bw() +\n    theme(axis.text.x = element_blank()) +\n    labs(\n        title = \"Assessment of species-specific synteny networks\",\n        subtitle = \"a = minimum # of anchors; m = maximum # of gaps\",\n        y = \"Scaled score (by species)\", x = \"\"\n    )\n    \nsynteny_scores_species\n\n\n\n\nScores for species-specific synteny networks.\n\n\n\n\nThe figure demonstrates that the best combination of parameters depends on the species, so there is no “universally” best combination. However, some patterns emerge. The combinations a = 7; m= 25 and a = 5; m = 15 are typically the worst. In some cases, they even lead to zero scores due to clustering coefficients of zero. Thus, if users want to test multiple combinations of parameters for their own data set, they should only test the combinations a = 3; m = 25, a = 5; m = 25, and a = 5; m = 35, which lead to the best score in 45%, 33%, and 22% of the species-specific networks, respectively. Interestingly, the combination that leads to the best score in most networks (a = 3; m = 25) is also the best when considering the whole Fabaceae synteny network (see previous section)."
  },
  {
    "objectID": "chapters/05_synteny_assessment_fabaceae.html#session-info",
    "href": "chapters/05_synteny_assessment_fabaceae.html#session-info",
    "title": "5  Assessing synteny detection in Fabaceae",
    "section": "Session info",
    "text": "Session info\nThis document was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.0 (2023-04-21)\n os       Ubuntu 20.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2023-08-04\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package              * version   date (UTC) lib source\n ape                    5.7-1     2023-03-13 [1] CRAN (R 4.3.0)\n aplot                  0.1.10    2023-03-08 [1] CRAN (R 4.3.0)\n beeswarm               0.4.0     2021-06-01 [1] CRAN (R 4.3.0)\n Biobase                2.60.0    2023-04-25 [1] Bioconductor\n BiocGenerics           0.46.0    2023-04-25 [1] Bioconductor\n BiocIO                 1.10.0    2023-04-25 [1] Bioconductor\n BiocManager            1.30.20   2023-02-24 [1] CRAN (R 4.3.0)\n BiocParallel           1.34.0    2023-04-25 [1] Bioconductor\n BiocStyle              2.28.0    2023-04-25 [1] Bioconductor\n Biostrings             2.68.0    2023-04-25 [1] Bioconductor\n bitops                 1.0-7     2021-04-24 [1] CRAN (R 4.3.0)\n cli                    3.6.1     2023-03-23 [1] CRAN (R 4.3.0)\n coda                   0.19-4    2020-09-30 [1] CRAN (R 4.3.0)\n codetools              0.2-19    2023-02-01 [4] CRAN (R 4.2.2)\n cogeqc               * 1.4.0     2023-04-25 [1] Bioconductor\n colorspace             2.1-0     2023-01-23 [1] CRAN (R 4.3.0)\n crayon                 1.5.2     2022-09-29 [1] CRAN (R 4.3.0)\n DelayedArray           0.26.1    2023-05-01 [1] Bioconductor\n digest                 0.6.31    2022-12-11 [1] CRAN (R 4.3.0)\n dplyr                * 1.1.2     2023-04-20 [1] CRAN (R 4.3.0)\n evaluate               0.20      2023-01-17 [1] CRAN (R 4.3.0)\n fansi                  1.0.4     2023-01-22 [1] CRAN (R 4.3.0)\n farver                 2.1.1     2022-07-06 [1] CRAN (R 4.3.0)\n fastmap                1.1.1     2023-02-24 [1] CRAN (R 4.3.0)\n forcats              * 1.0.0     2023-01-29 [1] CRAN (R 4.3.0)\n generics               0.1.3     2022-07-05 [1] CRAN (R 4.3.0)\n GenomeInfoDb           1.36.0    2023-04-25 [1] Bioconductor\n GenomeInfoDbData       1.2.10    2023-04-28 [1] Bioconductor\n GenomicAlignments      1.36.0    2023-04-25 [1] Bioconductor\n GenomicRanges          1.52.0    2023-04-25 [1] Bioconductor\n ggbeeswarm             0.7.2     2023-04-29 [1] CRAN (R 4.3.0)\n ggfun                  0.0.9     2022-11-21 [1] CRAN (R 4.3.0)\n ggnetwork              0.5.12    2023-03-06 [1] CRAN (R 4.3.0)\n ggplot2              * 3.4.1     2023-02-10 [1] CRAN (R 4.3.0)\n ggplotify              0.1.0     2021-09-02 [1] CRAN (R 4.3.0)\n ggsci                  3.0.0     2023-03-08 [1] CRAN (R 4.3.0)\n ggtree                 3.8.0     2023-04-25 [1] Bioconductor\n glue                   1.6.2     2022-02-24 [1] CRAN (R 4.3.0)\n gridGraphics           0.5-1     2020-12-13 [1] CRAN (R 4.3.0)\n gtable                 0.3.3     2023-03-21 [1] CRAN (R 4.3.0)\n here                 * 1.0.1     2020-12-13 [1] CRAN (R 4.3.0)\n hms                    1.1.3     2023-03-21 [1] CRAN (R 4.3.0)\n htmltools              0.5.5     2023-03-23 [1] CRAN (R 4.3.0)\n htmlwidgets            1.6.2     2023-03-17 [1] CRAN (R 4.3.0)\n igraph                 1.4.2     2023-04-07 [1] CRAN (R 4.3.0)\n intergraph             2.0-2     2016-12-05 [1] CRAN (R 4.3.0)\n IRanges                2.34.0    2023-04-25 [1] Bioconductor\n janeaustenr            1.0.0     2022-08-26 [1] CRAN (R 4.3.0)\n jsonlite               1.8.4     2022-12-06 [1] CRAN (R 4.3.0)\n knitr                  1.42      2023-01-25 [1] CRAN (R 4.3.0)\n labeling               0.4.2     2020-10-20 [1] CRAN (R 4.3.0)\n lattice                0.20-45   2021-09-22 [4] CRAN (R 4.2.0)\n lazyeval               0.2.2     2019-03-15 [1] CRAN (R 4.3.0)\n lifecycle              1.0.3     2022-10-07 [1] CRAN (R 4.3.0)\n lubridate            * 1.9.2     2023-02-10 [1] CRAN (R 4.3.0)\n magrittr               2.0.3     2022-03-30 [1] CRAN (R 4.3.0)\n Matrix                 1.5-1     2022-09-13 [4] CRAN (R 4.2.1)\n MatrixGenerics         1.12.2    2023-06-09 [1] Bioconductor\n matrixStats            1.0.0     2023-06-02 [1] CRAN (R 4.3.0)\n munsell                0.5.0     2018-06-12 [1] CRAN (R 4.3.0)\n network                1.18.1    2023-01-24 [1] CRAN (R 4.3.0)\n networkD3              0.4       2017-03-18 [1] CRAN (R 4.3.0)\n nlme                   3.1-162   2023-01-31 [4] CRAN (R 4.2.2)\n patchwork              1.1.2     2022-08-19 [1] CRAN (R 4.3.0)\n pheatmap               1.0.12    2019-01-04 [1] CRAN (R 4.3.0)\n pillar                 1.9.0     2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig              2.0.3     2019-09-22 [1] CRAN (R 4.3.0)\n plyr                   1.8.8     2022-11-11 [1] CRAN (R 4.3.0)\n purrr                * 1.0.1     2023-01-10 [1] CRAN (R 4.3.0)\n R6                     2.5.1     2021-08-19 [1] CRAN (R 4.3.0)\n RColorBrewer           1.1-3     2022-04-03 [1] CRAN (R 4.3.0)\n Rcpp                   1.0.10    2023-01-22 [1] CRAN (R 4.3.0)\n RCurl                  1.98-1.12 2023-03-27 [1] CRAN (R 4.3.0)\n readr                * 2.1.4     2023-02-10 [1] CRAN (R 4.3.0)\n reshape2               1.4.4     2020-04-09 [1] CRAN (R 4.3.0)\n restfulr               0.0.15    2022-06-16 [1] CRAN (R 4.3.0)\n rjson                  0.2.21    2022-01-09 [1] CRAN (R 4.3.0)\n rlang                  1.1.1     2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown              2.21      2023-03-26 [1] CRAN (R 4.3.0)\n rprojroot              2.0.3     2022-04-02 [1] CRAN (R 4.3.0)\n Rsamtools              2.16.0    2023-04-25 [1] Bioconductor\n rstudioapi             0.14      2022-08-22 [1] CRAN (R 4.3.0)\n rtracklayer            1.60.0    2023-04-25 [1] Bioconductor\n S4Arrays               1.0.1     2023-05-01 [1] Bioconductor\n S4Vectors              0.38.0    2023-04-25 [1] Bioconductor\n scales                 1.2.1     2022-08-20 [1] CRAN (R 4.3.0)\n sessioninfo            1.2.2     2021-12-06 [1] CRAN (R 4.3.0)\n SnowballC              0.7.1     2023-04-25 [1] CRAN (R 4.3.0)\n statnet.common         4.8.0     2023-01-24 [1] CRAN (R 4.3.0)\n stringi                1.7.12    2023-01-11 [1] CRAN (R 4.3.0)\n stringr              * 1.5.0     2022-12-02 [1] CRAN (R 4.3.0)\n SummarizedExperiment   1.30.1    2023-05-01 [1] Bioconductor\n syntenet             * 1.3.3     2023-06-15 [1] Bioconductor\n tibble               * 3.2.1     2023-03-20 [1] CRAN (R 4.3.0)\n tidyr                * 1.3.0     2023-01-24 [1] CRAN (R 4.3.0)\n tidyselect             1.2.0     2022-10-10 [1] CRAN (R 4.3.0)\n tidytext             * 0.4.1     2023-01-07 [1] CRAN (R 4.3.0)\n tidytree               0.4.2     2022-12-18 [1] CRAN (R 4.3.0)\n tidyverse            * 2.0.0     2023-02-22 [1] CRAN (R 4.3.0)\n timechange             0.2.0     2023-01-11 [1] CRAN (R 4.3.0)\n tokenizers             0.3.0     2022-12-22 [1] CRAN (R 4.3.0)\n treeio                 1.24.1    2023-05-31 [1] Bioconductor\n tzdb                   0.3.0     2022-03-28 [1] CRAN (R 4.3.0)\n utf8                   1.2.3     2023-01-31 [1] CRAN (R 4.3.0)\n vctrs                  0.6.2     2023-04-19 [1] CRAN (R 4.3.0)\n vipor                  0.4.5     2017-03-22 [1] CRAN (R 4.3.0)\n withr                  2.5.0     2022-03-03 [1] CRAN (R 4.3.0)\n xfun                   0.39      2023-04-20 [1] CRAN (R 4.3.0)\n XML                    3.99-0.14 2023-03-19 [1] CRAN (R 4.3.0)\n XVector                0.40.0    2023-04-25 [1] Bioconductor\n yaml                   2.3.7     2023-01-23 [1] CRAN (R 4.3.0)\n yulab.utils            0.0.6     2022-12-20 [1] CRAN (R 4.3.0)\n zlibbioc               1.46.0    2023-04-25 [1] Bioconductor\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "chapters/05_synteny_assessment_fabaceae.html#references",
    "href": "chapters/05_synteny_assessment_fabaceae.html#references",
    "title": "5  Assessing synteny detection in Fabaceae",
    "section": "References",
    "text": "References\n\n\n\n\nVan Bel, Michiel, Francesca Silvestri, Eric M Weitz, Lukasz Kreft, Alexander Botzki, Frederik Coppens, and Klaas Vandepoele. 2022. “PLAZA 5.0: Extending the Scope and Power of Comparative and Functional Genomics in Plants.” Nucleic Acids Research 50 (D1): D1468–74.\n\n\nWang, Yupeng, Haibao Tang, Jeremy D DeBarry, Xu Tan, Jingping Li, Xiyin Wang, Tae-ho Lee, et al. 2012. “MCScanX: A Toolkit for Detection and Evolutionary Analysis of Gene Synteny and Collinearity.” Nucleic Acids Research 40 (7): e49–49.\n\n\nZhao, Tao, and M Eric Schranz. 2019. “Network-Based Microsynteny Analysis Identifies Major Differences and Genomic Outliers in Mammalian and Angiosperm Genomes.” Proceedings of the National Academy of Sciences 116 (6): 2165–74."
  },
  {
    "objectID": "chapters/appendices.html#creating-paper-figures",
    "href": "chapters/appendices.html#creating-paper-figures",
    "title": "Appendices",
    "section": "Creating paper figures",
    "text": "Creating paper figures\nBelow you can find the code used to create the figures in the paper.\n\n#' In this document, you can find the code to combine individual plots into\n#' panels that will be used in the main text\n\n#----Load data------------------------------------------------------------------\nlibrary(here)\nlibrary(patchwork)\nlibrary(tidyverse)\nlibrary(cogeqc)\n\n# Part 0\n## A\noutput_dir &lt;- system.file(\"extdata\", package = \"cogeqc\")\nbusco_summary &lt;- read_busco(output_dir)\n\ndata(batch_summary)\n\n## B\nmaize_stats &lt;- get_genome_stats(taxon = \"Zea mays\")\nmy_stats &lt;- data.frame(\n    accession = \"my_lovely_maize\",\n    sequence_length = 2.4 * 1e9,\n    gene_count_total = 50000,\n    CC_ratio = 2\n)\n\n## C \nstats_dir &lt;- system.file(\"extdata\", package = \"cogeqc\")\northo_stats &lt;- read_orthofinder_stats(stats_dir)\ndata(tree)\n\n\n# Part 1\nload(here(\"products\", \"plots\", \"combined_tree_chlorophyta.rda\"))\n\n# Part 2\n## A\nload(here(\"products\", \"plots\", \"plot_homogeneity_scores_dbs.rda\")) # distros\n\n## B\nload(here(\"products\", \"plots\", \"p_distros_global.rda\")) \nload(here(\"products\", \"plots\", \"p_distros_mcl.rda\")) \nload(here(\"products\", \"plots\", \"p_distros_diamond.rda\"))\nload(here(\"products\", \"plots\", \"p_distros_by_species.rda\"))\nload(here(\"products\", \"plots\", \"p_treeplot.rda\"))\nload(here(\"products\", \"plots\", \"p_distros_groups.rda\"))\nload(here(\"products\", \"plots\", \"p_association_length_homogeneity.rda\"))\nload(here(\"products\", \"plots\", \"relationship_og_number_and_size.rda\"))\n\n# Part 3\nload(here(\"products\", \"plots\", \"synteny_scores_fabaceae.rda\"))\nload(here(\"products\", \"plots\", \"synteny_scores_species.rda\"))\n\n\n#----Combine plots and create figs----------------------------------------------\n## Figure 0: Example of figures that can be created with graphical functions\nfig0_p1 &lt;- plot_genome_stats(ncbi_stats = maize_stats, user_stats = my_stats)\n\nfig0_p2 &lt;- wrap_plots(\n    plot_busco(busco_summary),\n    plot_busco(batch_summary),\n    ncol = 2\n) +\n    theme(legend.position = \"bottom\")\n\nog_overlap &lt;- plot_og_overlap(ortho_stats) +\n    scale_fill_gradient(\n        low = \"#E5F5E0\", high = \"#00441B\", name = \"Overlap size (K)\",\n        label = scales::unit_format(unit = \"\", scale = 1e-3)\n    ) +\n    theme(legend.position = \"bottom\")\n\n\nfig0_p3 &lt;- wrap_plots(\n    plot_orthofinder_stats(\n        tree, stats_list = ortho_stats, xlim = c(-0.1, 2)\n    ),\n    og_overlap,\n    widths = c(4, 1), \n    nrow = 1\n)\n\nfig0 &lt;- wrap_plots(\n    fig0_p1, \n    fig0_p2,\n    fig0_p3,\n    ncol = 1,\n    heights = c(2, 1, 1.5)\n) + \n    plot_annotation(tag_levels = list(\n        c(\"A\", rep(\"\", 11), \"B\", \"C\", \"D\", rep(\"\", 3), \"E\")\n    ))\n\n\n## Figure 1: BUSCO assessment\nfig1 &lt;- combined + \n    ggtitle(\"Percentage of BUSCOs for each species\") +\n    plot_layout(guides = \"collect\", widths = c(2,3)) &\n    theme(legend.position = \"bottom\") &\n    ggplot2::scale_fill_manual(labels = c(\n        \"Complete & SC\", \"Complete & duplicate\", \"Fragmented\", \"Missing\"\n    ),\n    values = c(\n        \"#32709a\", \"#59AAE1\", \"darkgoldenrod2\", \"#db5850\"\n    )) \n\n\n## Figure 2: Orthogroup assessment\np_distros_global &lt;- p_distros_global +\n    scale_x_discrete(\n        labels = c(\n            \"default_1\" = \"Default, 1\",\n            \"default_1_5\" = \"Default, 1.5\",\n            \"default_2\" = \"Default, 2\",\n            \"default_3\" = \"Default, 3\",\n            \"ultra_1\" = \"Ultra, 1\",\n            \"ultra_1_5\" = \"Ultra, 1.5\",\n            \"ultra_2\" = \"Ultra, 2\",\n            \"ultra_3\" = \"Ultra, 3\"\n        )\n    )\n\np_distros_diamond &lt;- p_distros_diamond + \n    ggtitle(\"Effect of DIAMOND mode on orthogroup inference\")\n\n\np_association_length_homogeneity &lt;- p_association_length_homogeneity + \n    ggtitle(\"Relationship between OG homogeneity and gene length\")\n\n\npercentage_bars &lt;- percentage_plot + scale_y_discrete(\n    labels = c(\n        \"default_1\" = \"Default, 1\",\n        \"default_1_5\" = \"Default, 1.5\",\n        \"default_2\" = \"Default, 2\",\n        \"default_3\" = \"Default, 3\",\n        \"ultra_1\" = \"Ultra, 1\",\n        \"ultra_1_5\" = \"Ultra, 1.5\",\n        \"ultra_2\" = \"Ultra, 2\",\n        \"ultra_3\" = \"Ultra, 3\"\n    )\n) +\n    ggpubr::theme_pubr()\n\n\nfig2 &lt;- patchwork::wrap_plots(\n    wrap_plots(distros, p_distros_global, nrow = 1), # row 1\n    p_distros_by_species + \n        theme(axis.text.x = element_text(angle = 60, vjust = 0.5)), # row 2\n    wrap_plots(p_distros_mcl, p_distros_diamond, nrow = 1), # row 3\n    percentage_bars, # row 4\n    ncol = 1\n) + \n    plot_annotation(tag_levels = \"A\")\n\n## Figure 3: sequence and score relationship + functional analysis of OG clusters\n### Change font size of tip labels\nptree &lt;- p_treeplot\nptree[[1]]$layers[[6]]$aes_params$size &lt;- 3.5\nptree[[2]]$layers[[6]]$aes_params$size &lt;- 3.5\nptree[[3]]$layers[[6]]$aes_params$size &lt;- 3.5\nptree[[2]]$data$label &lt;- gsub(\" \\\\(.*\", \"\", ptree[[2]]$data$label)\nptree[[2]]$data$label &lt;- gsub(\n    \"signaling pathway\", \"signaling\", ptree[[2]]$data$label\n)\n\nupper &lt;- wrap_plots(p_association_length_homogeneity, p_distros_groups, widths = c(1, 1.5))\nbottom &lt;- ptree + theme(plot.margin = margin(0, 0, 0, 0, \"pt\"))\n\nfig3 &lt;- wrap_plots(upper, plot_spacer(), heights = c(1, 2)) +\n    inset_element(bottom, 0, 0, 1, 1, align_to = \"full\") +\n    plot_annotation(tag_levels = \"A\")\n\n\n## Figure 4: synteny\nfig4 &lt;- wrap_plots(\n    synteny_scores_fabaceae, \n    synteny_scores_species + theme(legend.position = \"bottom\"),\n    ncol = 1, heights = c(1, 3)\n) +\n    plot_annotation(tag_levels = \"A\")\n\n\n#----Save plots in figs/ -------------------------------------------------------\n## Figure 0\nggsave(\n    fig0, \n    filename = here(\"products\", \"figs\", \"figure_0_graphical_functions.png\"),\n    width = 18, height = 12, dpi = 400\n)\n\nggsave(\n    fig0, \n    filename = here(\"products\", \"figs\", \"figure_0_graphical_functions.pdf\"),\n    width = 19, height = 12\n)\n\n\n## Figure 1\nggsave(\n    fig1,\n    filename = here(\"products\", \"figs\", \"figure_1_busco_assessment.png\"),\n    width = 13, height = 8, dpi = 600\n)\n\nggsave(\n    fig1,\n    filename = here(\"products\", \"figs\", \"figure_1_busco_assessment.pdf\"),\n    width = 13, height = 8\n)\n\n## Figure 2\nggsave(\n    fig2,\n    filename = here(\"products\", \"figs\", \"figure_2_homogeneity_assessment.png\"),\n    width = 17, height = 18, dpi = 300\n)\n\nggsave(\n    fig2,\n    filename = here(\"products\", \"figs\", \"figure_2_homogeneity_assessment.pdf\"),\n    width = 17, height = 18\n)\n\n# Figure 3\nggsave(\n    fig3, \n    filename = here(\"products\", \"figs\", \"figure_3_ogs_brassicaceae.png\"),\n    width = 23, height = 12, dpi = 300\n)\n\nggsave(\n    fig3, \n    filename = here(\"products\", \"figs\", \"figure_3_ogs_brassicaceae.pdf\"),\n    width = 23, height = 12\n)\n\n# Figure 4\nggsave(\n    fig4, \n    filename = here(\"products\", \"figs\", \"figure_4_synteny_assessment.png\"),\n    width = 8, height = 10, dpi = 300\n)\n\nggsave(\n    fig4, \n    filename = here(\"products\", \"figs\", \"figure_4_synteny_assessment.pdf\"),\n    width = 8, height = 10\n)"
  },
  {
    "objectID": "chapters/appendices.html#utility-functions",
    "href": "chapters/appendices.html#utility-functions",
    "title": "Appendices",
    "section": "Utility functions",
    "text": "Utility functions\nBelow you can find the source code for some helper functions/wrappers that are used in the main chapters.\n\nextract_ogs_uniprot &lt;- function(proteins = NULL) {\n    \n    ogs &lt;- lapply(proteins, function(x) {\n        \n        url &lt;- paste0(\"https://www.ebi.ac.uk/proteins/api/proteins/\", x)\n        request &lt;- httr::GET(url)\n        annot &lt;- httr::content(request, type = \"application/json\", \n                               as = \"parsed\", encoding = \"UTF-8\")\n        dbref &lt;- lapply(annot$dbReferences, as.data.frame)\n        names(dbref) &lt;- vapply(dbref, function(x) return(x$type), character(1))\n        \n        orthodb &lt;- NA\n        eggnog &lt;- NA\n        inparanoid &lt;- NA\n        phylomedb &lt;- NA\n        hogenom &lt;- NA\n        if(\"eggNOG\" %in% names(dbref)) {\n            eggnog &lt;- dbref$eggNOG$id\n        }\n        if(\"OrthoDB\" %in% names(dbref)) {\n            orthodb &lt;- dbref$OrthoDB$id\n        }\n        if(\"InParanoid\" %in% names(dbref)) {\n            inparanoid &lt;- dbref$InParanoid$id\n        }\n        if(\"PhylomeDB\" %in% names(dbref)) {\n            phylomedb &lt;- dbref$PhylomeDB$id\n        }\n        if(\"HOGENOM\" %in% names(dbref)) {\n            hogenom &lt;- dbref$HOGENOM$id\n        }\n        if(!\"Araport\" %in% names(dbref)) {\n            df &lt;- NULL\n        } else {\n            df &lt;- data.frame(\n                Gene = dbref$Araport$id,\n                OrthoDB = orthodb,\n                eggNOG = eggnog,\n                OrthoDB = orthodb,\n                InParanoid = inparanoid,\n                PhylomeDB = phylomedb,\n                HOGENOM = hogenom\n            )\n        }\n        return(df)\n    })\n    og_df &lt;- Reduce(rbind, ogs)\n    return(og_df)\n}\n\n\ncompare &lt;- function(data, form, ref = NULL) {\n    # Wilcoxon test - greater and less alternatives\n    wilcoxtest_greater &lt;- tibble::as_tibble(data) %&gt;%\n        rstatix::wilcox_test(\n            formula(form), p.adjust.method = \"BH\", ref.group = ref,\n            alternative = \"greater\"\n        )\n    pg &lt;- ifelse(\"p.adj\" %in% names(wilcoxtest_greater), \"p.adj\", \"p\")\n    wilcoxtest_greater &lt;- wilcoxtest_greater %&gt;% dplyr::select(\n            group1, group2, n1, n2, padj_greater = all_of(pg)\n        )\n    \n    wilcoxtest_less &lt;- tibble::as_tibble(data) %&gt;%\n        rstatix::wilcox_test(\n            formula(form), p.adjust.method = \"BH\", ref.group = ref,\n            alternative = \"less\"\n        )\n    pl &lt;- ifelse(\"p.adj\" %in% names(wilcoxtest_less), \"p.adj\", \"p\")\n    wilcoxtest_less &lt;- wilcoxtest_less %&gt;% dplyr::select(\n        group1, group2, n1, n2, padj_less = all_of(pl)\n    )\n    \n    wilcox_summary &lt;- dplyr::inner_join(wilcoxtest_greater, wilcoxtest_less) %&gt;%\n        dplyr::mutate(padj_interpretation = dplyr::case_when(\n            padj_less &lt; 0.05 ~ \"less\",\n            padj_greater &lt; 0.05 ~ \"greater\",\n            TRUE ~ \"ns\"\n        ))\n    \n    # Effect sizes for Wilcoxon test - greater and less alternatives\n    \n    effsize &lt;- tibble::as_tibble(data) %&gt;%\n        rstatix::wilcox_effsize(\n            formula(form), ref.group = ref,\n        ) %&gt;%\n        dplyr::select(\n            group1, group2, effsize, magnitude\n        )\n    \n    \n    result &lt;- as.data.frame(inner_join(wilcox_summary, effsize))\n        \n    return(result)\n}\n\n\nfilter_comparison &lt;- function(compare_output) {\n    \n    filtered_df &lt;- compare_output |&gt;\n        dplyr::filter(padj_interpretation != \"ns\") |&gt;\n        mutate(padj = case_when(\n            padj_interpretation == \"greater\" ~ padj_greater,\n            padj_interpretation == \"less\" ~ padj_less\n        )) |&gt;\n        dplyr::select(group1, group2, n1, n2, padj, effsize, magnitude)\n    \n    return(filtered_df)\n}"
  },
  {
    "objectID": "chapters/appendices.html#bash-code",
    "href": "chapters/appendices.html#bash-code",
    "title": "Appendices",
    "section": "Bash code",
    "text": "Bash code\nBelow, you can find the Bash code I used to run OrthoFinder.\n\n#!/bin/bash\n\n# Define paths\nworkdir='/home/faalm/projects/cogeqc_benchmark'\noutdir='/home/faalm/projects/cogeqc_benchmark/products/result_files'\n\n# Run OrthoFinder - default DIAMOND\northofinder -f \"$workdir/data\" -S diamond -I 1.5 -o \"$outdir/default_1_5\" -og\northofinder -f \"$workdir/data\" -S diamond -I 2 -o \"$outdir/default_2\" -og\northofinder -f \"$workdir/data\" -S diamond -I 3 -o \"$outdir/default_3\" -og\northofinder -f \"$workdir/data\" -S diamond -I 1 -o \"$outdir/default_1\" -og\n\n# Run OrthoFinder - ultrasensitive DIAMOND\northofinder -f \"$workdir/data\" -S diamond_ultra_sens -I 1.5 -t 8 -o \"$outdir/ultra_1_5\" -og\northofinder -f \"$workdir/data\" -S diamond_ultra_sens -I 2 -t 8 -o \"$outdir/ultra_2\" -og\northofinder -f \"$workdir/data\" -S diamond_ultra_sens -I 3 -t 8 -o \"$outdir/ultra_3\" -og\northofinder -f \"$workdir/data\" -S diamond_ultra_sens -I 1 -t 8 -o \"$outdir/ultra_1\" -og"
  },
  {
    "objectID": "chapters/appendices.html#session-information",
    "href": "chapters/appendices.html#session-information",
    "title": "Appendices",
    "section": "Session information",
    "text": "Session information\nThis document was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.0 (2023-04-21)\n os       Ubuntu 20.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2023-08-04\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.1   2023-03-23 [1] CRAN (R 4.3.0)\n digest        0.6.31  2022-12-11 [1] CRAN (R 4.3.0)\n evaluate      0.20    2023-01-17 [1] CRAN (R 4.3.0)\n fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.3.0)\n htmltools     0.5.5   2023-03-23 [1] CRAN (R 4.3.0)\n htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.3.0)\n jsonlite      1.8.4   2022-12-06 [1] CRAN (R 4.3.0)\n knitr         1.42    2023-01-25 [1] CRAN (R 4.3.0)\n rlang         1.1.1   2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown     2.21    2023-03-26 [1] CRAN (R 4.3.0)\n rstudioapi    0.14    2022-08-22 [1] CRAN (R 4.3.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n xfun          0.39    2023-04-20 [1] CRAN (R 4.3.0)\n yaml          2.3.7   2023-01-23 [1] CRAN (R 4.3.0)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────"
  }
]